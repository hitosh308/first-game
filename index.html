<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ミニゲームセレクト</title>
  <style>
    :root {
      color-scheme: dark light;
      --bg: #10131a;
      --panel: rgba(20, 27, 39, 0.85);
      --accent: #6cf;
      --green: #38c172;
      --purple: #9966ff;
      --ice: #4ec7ff;
      --warp: #ff7de9;
      --crumble: #d4b483;
      --door-gold: #f5c542;
      --door-blue: #3f8cff;
      --door-red: #ff5f6d;
      --text: #f5f7fa;
      font-family: 'Segoe UI', 'Hiragino Sans', sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(80,120,200,0.18), transparent 55%), var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }
    body.menu-active header,
    body.menu-active main,
    body.menu-active footer {
      display: none;
    }
    body:not(.maze-active) header,
    body:not(.maze-active) main,
    body:not(.maze-active) footer,
    body:not(.maze-active) #homeOverlay,
    body:not(.maze-active) #clearOverlay,
    body:not(.maze-active) #howToModal,
    body:not(.maze-active) #toast {
      display: none !important;
    }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    .menu-screen {
      display: none;
      flex: 1;
      align-items: center;
      justify-content: center;
      padding: 3rem 1.5rem;
      background: radial-gradient(circle at top, rgba(120,160,255,0.12), transparent 55%);
      min-height: 100vh;
    }
    body.menu-active .menu-screen {
      display: flex;
    }
    .menu-content {
      max-width: 960px;
      width: 100%;
      background: rgba(12,18,28,0.82);
      border-radius: 1.25rem;
      padding: 2.5rem clamp(1.5rem, 4vw, 3rem);
      box-shadow: 0 24px 60px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }
    .menu-header h1 {
      margin: 0 0 0.75rem;
      font-size: clamp(2rem, 4vw, 2.75rem);
    }
    .menu-header p {
      margin: 0;
      color: rgba(245,247,250,0.8);
      line-height: 1.7;
      font-size: 1rem;
    }
    .menu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
    }
    .menu-card {
      background: rgba(20,27,39,0.9);
      border-radius: 1rem;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      border: 1px solid rgba(255,255,255,0.08);
      position: relative;
      overflow: hidden;
    }
    .menu-card::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(110,200,255,0.18), transparent 55%);
      opacity: 0.6;
      pointer-events: none;
      z-index: 0;
    }
    .menu-card > * {
      position: relative;
      z-index: 1;
    }
    .menu-card h2 {
      margin: 0;
      font-size: 1.4rem;
    }
    .menu-card p {
      margin: 0;
      line-height: 1.6;
      color: rgba(245,247,250,0.78);
    }
    .menu-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .menu-card.coming-soon {
      align-items: flex-start;
      justify-content: center;
      color: rgba(245,247,250,0.5);
    }
    .menu-card.coming-soon::before {
      background: radial-gradient(circle at top left, rgba(180,160,255,0.18), transparent 55%);
    }
    .menu-card.coming-soon span {
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(255,255,255,0.08);
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
    }
    header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: rgba(8, 12, 20, 0.75);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 20;
    }
    header .controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    header .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.25rem 0.75rem;
      min-width: 260px;
      flex: 1;
    }
    header .stat {
      display: flex;
      flex-direction: column;
      font-size: 0.8rem;
      background: rgba(255, 255, 255, 0.06);
      padding: 0.35rem 0.5rem;
      border-radius: 0.35rem;
      min-width: 120px;
    }
    header .stat strong { font-size: 0.95rem; font-weight: 600; }
    button, select, input {
      font: inherit;
      border-radius: 0.45rem;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: inherit;
      padding: 0.4rem 0.75rem;
      cursor: pointer;
      transition: transform 0.1s ease, background 0.2s ease;
    }
    button:hover, select:hover { background: rgba(255,255,255,0.18); }
    button:active { transform: scale(0.97); }
    select { padding-right: 1.8rem; }
    main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      position: relative;
    }
    .canvas-shell {
      position: relative;
      width: min(90vw, 720px);
      aspect-ratio: 1 / 1;
      background: rgba(12,18,28,0.75);
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    }
    #mazeCanvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(10, 14, 24, 0.92);
      color: var(--text);
      padding: 1.5rem;
      gap: 1rem;
      text-align: center;
      overflow-y: auto;
    }
    .overlay.hidden { display: none; }
    .overlay h1, .overlay h2 { margin: 0; }
    .home-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    .seed-entry {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    .seed-entry input { min-width: 160px; }
    .stage-columns {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      width: 100%;
    }
    .stage-column {
      background: rgba(255,255,255,0.05);
      padding: 0.75rem;
      border-radius: 0.75rem;
      width: min(240px, 100%);
    }
    .stage-column h2 {
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
    }
    .stage-buttons {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 0.4rem;
    }
    .stage-buttons button { padding: 0.5rem 0.25rem; border-radius: 0.5rem; }
    .stage-buttons button.locked {
      opacity: 0.35;
      cursor: not-allowed;
      position: relative;
    }
    .stage-buttons button.locked::after {
      content: '\1f512';
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 1.1rem;
    }
    .badge {
      font-size: 0.8rem;
      padding: 0.1rem 0.4rem;
      background: rgba(255,255,255,0.1);
      border-radius: 999px;
      margin-left: 0.35rem;
    }
    footer {
      padding: 0.75rem;
      text-align: center;
      font-size: 0.85rem;
      color: rgba(255,255,255,0.7);
    }
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.6);
      padding: 1rem;
      z-index: 50;
    }
    .modal.hidden { display: none; }
    .modal-content {
      background: rgba(10,14,24,0.95);
      border-radius: 0.75rem;
      padding: 1.25rem;
      max-width: 420px;
      width: 100%;
      text-align: left;
      line-height: 1.6;
    }
    .modal-content h2 { margin-top: 0; }
    .toast {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      padding: 0.5rem 1rem;
      border-radius: 999px;
      font-size: 0.9rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 60;
    }
    .toast.show {
      opacity: 1;
      transform: translate(-50%, -0.25rem);
    }
    #shooterApp {
      display: none;
      flex-direction: column;
      min-height: 100vh;
    }
    body.shooter-active #shooterApp {
      display: flex;
    }
    #shooterApp[data-mode='score'] .shooter-stat[data-mode='score'],
    #shooterApp[data-mode='survival'] .shooter-stat:not([data-mode]),
    #shooterApp[data-mode='survival'] .shooter-stat[data-mode='survival'],
    #shooterApp[data-mode='score'] .shooter-stat:not([data-mode]) {
      display: flex;
    }
    #shooterApp[data-mode='score'] .shooter-stat[data-mode='survival'],
    #shooterApp[data-mode='survival'] .shooter-stat[data-mode='score'] {
      display: none;
    }
    .shooter-topbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: rgba(8, 12, 20, 0.78);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 30;
    }
    .shooter-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .shooter-mode-toggle {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
    }
    .shooter-mode-toggle button {
      border: none;
      background: transparent;
      padding: 0.35rem 0.9rem;
      cursor: pointer;
      color: inherit;
      font: inherit;
      transition: background 0.2s ease;
    }
    .shooter-mode-toggle button.active {
      background: rgba(255,255,255,0.25);
    }
    .shooter-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.35rem 0.75rem;
      min-width: 260px;
      flex: 1;
    }
    .shooter-stat {
      display: none;
      flex-direction: column;
      font-size: 0.8rem;
      background: rgba(255,255,255,0.06);
      padding: 0.35rem 0.5rem;
      border-radius: 0.35rem;
      min-width: 120px;
    }
    .shooter-stat strong {
      font-size: 0.95rem;
      font-weight: 600;
    }
    .shooter-main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      position: relative;
    }
    .shooter-canvas-shell {
      position: relative;
      width: min(90vw, 520px);
      aspect-ratio: 9 / 16;
      background: rgba(12,18,28,0.78);
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      touch-action: none;
    }
    #shooterCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .shooter-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem 1.5rem;
      gap: 1rem;
      text-align: center;
      background: rgba(9, 13, 22, 0.9);
    }
    .shooter-overlay.hidden {
      display: none;
    }
    .shooter-panel {
      background: rgba(255,255,255,0.06);
      padding: 1.5rem;
      border-radius: 1rem;
      max-width: 420px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .shooter-panel h1,
    .shooter-panel h2 {
      margin: 0;
    }
    .shooter-panel p {
      margin: 0;
      line-height: 1.6;
      color: rgba(245,247,250,0.85);
    }
    .shooter-panel ul {
      margin: 0;
      padding-left: 1.1rem;
      text-align: left;
      color: rgba(245,247,250,0.78);
      line-height: 1.5;
    }
    .shooter-panel ul li + li {
      margin-top: 0.35rem;
    }
    .shooter-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    .shooter-toast {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      padding: 0.5rem 1rem;
      border-radius: 999px;
      font-size: 0.9rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .shooter-toast.show {
      opacity: 1;
      transform: translate(-50%, -0.25rem);
    }
    .clear-panel {
      background: rgba(255,255,255,0.05);
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      width: min(360px, 100%);
    }
    .clear-panel h2 {
      margin: 0;
      font-size: 1.8rem;
      color: var(--accent);
    }
    .clear-panel .scoreline {
      display: flex;
      justify-content: space-between;
    }
    @media (max-width: 720px) {
      header {
        flex-direction: column;
        align-items: stretch;
      }
      header .controls {
        width: 100%;
        justify-content: center;
      }
      header .stats { width: 100%; }
      .canvas-shell { width: min(100%, 520px); }
      .menu-content {
        padding: 2rem 1.25rem;
      }
      .menu-grid {
        grid-template-columns: 1fr;
      }
      .shooter-topbar {
        flex-direction: column;
        align-items: stretch;
      }
      .shooter-controls {
        width: 100%;
        justify-content: center;
      }
      .shooter-stats {
        width: 100%;
      }
      .shooter-canvas-shell {
        width: min(100%, 420px);
      }
    }
  </style>
</head>
<body class="menu-active">
  <div class="menu-screen" id="menuScreen" role="dialog" aria-modal="true" aria-hidden="false">
    <div class="menu-content">
      <div class="menu-header">
        <h1>ミニゲームセレクト</h1>
        <p>これから少しずつゲームが増えていく予定です。迷路に挑むも良し、弾幕をくぐるも良し。お気に入りのモードで腕試ししてみましょう！</p>
      </div>
      <div class="menu-grid">
        <article class="menu-card">
          <h2>一筆書き迷路</h2>
          <p>スタートからゴールまで、同じ道を二度と通らずに駆け抜けるスピードラン型の迷路ゲームです。</p>
          <div class="menu-actions">
            <button id="menuStartBtn">ステージを選ぶ</button>
            <button id="menuContinueBtn">続きから</button>
          </div>
        </article>
        <article class="menu-card">
          <h2>弾幕サーファー</h2>
          <p>怒涛の弾幕を乗りこなし、爽快な連続撃破でスコアを稼ぐ縦スクロールシューティングです。</p>
          <div class="menu-actions">
            <button id="menuShooterScoreBtn">スコアアタック</button>
            <button id="menuShooterSurvivalBtn">サバイバル</button>
          </div>
        </article>
      </div>
    </div>
  </div>
  <header>
    <div class="controls">
      <button id="menuReturnBtn" aria-label="メニューに戻る">メニュー</button>
      <button id="newGameBtn" aria-label="新しい迷路を生成">新しい迷路</button>
      <label class="badge" for="difficultySelect">難易度</label>
      <select id="difficultySelect" aria-label="難易度選択">
        <option value="easy">やさしい</option>
        <option value="normal">ふつう</option>
        <option value="hard">むずかしい</option>
      </select>
      <button id="levelSelectBtn" aria-label="レベルセレクトを開く">レベルセレクト</button>
      <button id="howToBtn" aria-label="遊び方を表示">遊び方</button>
      <button id="muteBtn" aria-label="ミュート切替" aria-pressed="false">🔊</button>
    </div>
    <div class="stats" role="status" aria-live="polite">
      <div class="stat"><span>タイム</span><strong id="timeLabel">0.00s</strong></div>
      <div class="stat"><span>手数</span><strong id="stepsLabel">0</strong></div>
      <div class="stat"><span>残り時間</span><strong id="timeRemainLabel">--</strong></div>
      <div class="stat"><span>残り手数</span><strong id="stepsRemainLabel">--</strong></div>
      <div class="stat"><span>スコア</span><strong id="scoreLabel">0</strong></div>
      <div class="stat"><span>連勝倍率</span><strong id="comboLabel">1.0x</strong></div>
      <div class="stat"><span>ベストタイム</span><strong id="bestTimeLabel">--</strong></div>
      <div class="stat"><span>ベストスコア</span><strong id="bestScoreLabel">--</strong></div>
    </div>
  </header>
  <main>
    <div class="canvas-shell" id="canvasShell">
      <canvas id="mazeCanvas" aria-label="一筆書き迷路"></canvas>
      <div class="overlay" id="homeOverlay" role="dialog" aria-modal="true">
        <h1>一筆書き迷路</h1>
        <p>スタートからゴールまで、一筆書きで駆け抜けよう！</p>
        <div class="home-actions">
          <button id="continueBtn">続きから</button>
          <button id="randomBtn">ランダム</button>
          <button id="seedCopyBtn">現在のシードをコピー</button>
        </div>
        <div class="seed-entry" aria-label="シード指定">
          <input id="seedInput" type="text" placeholder="seed" />
          <select id="seedDifficulty">
            <option value="easy">やさしい</option>
            <option value="normal">ふつう</option>
            <option value="hard">むずかしい</option>
          </select>
          <input id="seedStage" type="number" min="1" max="10" value="1" aria-label="ステージ番号" />
          <button id="seedStartBtn">シード開始</button>
        </div>
        <div class="stage-columns" id="stageColumns"></div>
      </div>
      <div class="overlay hidden" id="clearOverlay" role="dialog" aria-modal="true">
        <div class="clear-panel">
          <h2>クリア！</h2>
          <div class="scoreline"><span>タイム</span><strong id="clearTime">0.00s</strong></div>
          <div class="scoreline"><span>手数</span><strong id="clearSteps">0</strong></div>
          <div class="scoreline"><span>スコア</span><strong id="clearScore">0</strong></div>
          <div class="scoreline"><span>ベスト更新</span><strong id="clearBest">-</strong></div>
          <div class="home-actions">
            <button id="nextStageBtn">次のステージ</button>
            <button id="retryBtn">もう一度</button>
            <button id="shareBtn">Share</button>
          </div>
        </div>
      </div>
    </div>
  </main>
  <footer id="statusLine">ドラッグ（長押し）でスタートからゴールへ。一度通った道は戻れません。Escでリセット。</footer>
  <div class="modal hidden" id="howToModal" role="dialog" aria-modal="true" aria-labelledby="howToTitle">
    <div class="modal-content">
      <h2 id="howToTitle">遊び方</h2>
      <p>スタート地点を押し、指やマウスを離さずにゴールまで進みます。同じマスや道を二度通ることはできません。氷は滑り、一方通行は矢印の向きにしか進めません。鍵を取ると対応する扉が開き、ワープはペアのマスへ瞬間移動します。崩れる床は一度だけ渡れます。</p>
      <p>時間と手数の制限に気をつけて、コンボ倍率を育てながら高スコアを目指しましょう！</p>
      <button id="howToCloseBtn">閉じる</button>
    </div>
  </div>
  <div class="toast" id="toast"></div>
  <div id="shooterApp" class="shooter-app" data-mode="score" aria-hidden="true">
    <div class="shooter-topbar" role="toolbar">
      <div class="shooter-controls">
        <button id="shooterMenuBtn" aria-label="メニューに戻る">メニュー</button>
        <div class="shooter-mode-toggle" role="tablist" aria-label="モード切替">
          <button type="button" class="active" data-mode-select="score" role="tab" aria-selected="true">スコア</button>
          <button type="button" data-mode-select="survival" role="tab" aria-selected="false">サバイバル</button>
        </div>
        <label class="badge" for="shooterDifficulty">難易度</label>
        <select id="shooterDifficulty" aria-label="難易度選択">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
        <button id="shooterBombBtn" type="button" aria-label="ボムを使用">ボム</button>
        <button id="shooterMuteBtn" aria-label="ミュート切替" aria-pressed="false">🔊</button>
      </div>
      <div class="shooter-stats" role="status" aria-live="polite">
        <div class="shooter-stat"><span>スコア</span><strong id="shooterScoreLabel">0</strong></div>
        <div class="shooter-stat" data-mode="score"><span>残り時間</span><strong id="shooterTimerLabel">60.0s</strong></div>
        <div class="shooter-stat" data-mode="survival"><span>残りHP</span><strong id="shooterHpLabel">3</strong></div>
        <div class="shooter-stat"><span>ボム</span><strong id="shooterBombLabel">0</strong></div>
        <div class="shooter-stat"><span>シールド</span><strong id="shooterShieldLabel">OFF</strong></div>
        <div class="shooter-stat"><span>チェイン</span><strong id="shooterChainLabel">x1.0</strong></div>
        <div class="shooter-stat"><span>ベスト</span><strong id="shooterBestLabel">0</strong></div>
      </div>
    </div>
    <div class="shooter-main">
      <div class="shooter-canvas-shell" id="shooterCanvasShell">
        <canvas id="shooterCanvas" aria-label="弾幕サーファー"></canvas>
        <div class="shooter-overlay" id="shooterStartOverlay" role="dialog" aria-modal="true">
          <div class="shooter-panel">
            <h1>弾幕サーファー</h1>
            <p>自機は常にオートショット。スワイプや矢印キーで滑るように弾幕をくぐり抜け、同時撃破でチェイン倍率を伸ばそう。</p>
            <ul>
              <li>ドラッグ / 矢印キー / WASD・AD で移動</li>
              <li>スペースキーまたはボタンでボム発動（敵弾全消去＋大ダメージ）</li>
              <li>スコアチップ・シールド・ボムのアイテムを回収</li>
            </ul>
            <div class="shooter-actions">
              <button type="button" data-start-mode="score">スコアアタック開始</button>
              <button type="button" data-start-mode="survival">サバイバル開始</button>
            </div>
          </div>
        </div>
        <div class="shooter-overlay hidden" id="shooterGameOverOverlay" role="dialog" aria-modal="true">
          <div class="shooter-panel">
            <h2 id="shooterGameOverTitle">リザルト</h2>
            <p><strong>最終スコア</strong> <span id="shooterFinalScore">0</span></p>
            <p><strong>ベストスコア</strong> <span id="shooterBestScore">0</span></p>
            <div class="shooter-actions">
              <button id="shooterRetryBtn" type="button">リトライ</button>
              <button id="shooterModeSelectBtn" type="button">モード選択</button>
              <button id="shooterMenuFromResultBtn" type="button">メニュー</button>
            </div>
          </div>
        </div>
        <div class="shooter-toast" id="shooterToast" role="status" aria-live="polite"></div>
      </div>
    </div>
  </div>
  <script>
  (() => {
    const $ = (sel) => document.querySelector(sel);
    const canvas = $('#mazeCanvas');
    const ctx = canvas.getContext('2d');
    const shell = $('#canvasShell');
    const homeOverlay = $('#homeOverlay');
    const clearOverlay = $('#clearOverlay');
    const howToModal = $('#howToModal');
    const toastEl = $('#toast');
    const menuScreen = $('#menuScreen');
    const shooterApp = $('#shooterApp');

    const menuStartBtn = $('#menuStartBtn');
    const menuContinueBtn = $('#menuContinueBtn');
    const menuReturnBtn = $('#menuReturnBtn');

    const difficultySelect = $('#difficultySelect');
    const stageColumns = $('#stageColumns');
    const continueBtn = $('#continueBtn');
    const randomBtn = $('#randomBtn');
    const seedCopyBtn = $('#seedCopyBtn');
    const seedInput = $('#seedInput');
    const seedDifficulty = $('#seedDifficulty');
    const seedStage = $('#seedStage');
    const seedStartBtn = $('#seedStartBtn');
    const newGameBtn = $('#newGameBtn');
    const levelSelectBtn = $('#levelSelectBtn');
    const howToBtn = $('#howToBtn');
    const howToCloseBtn = $('#howToCloseBtn');
    const muteBtn = $('#muteBtn');

    const timeLabel = $('#timeLabel');
    const stepsLabel = $('#stepsLabel');
    const timeRemainLabel = $('#timeRemainLabel');
    const stepsRemainLabel = $('#stepsRemainLabel');
    const scoreLabel = $('#scoreLabel');
    const comboLabel = $('#comboLabel');
    const bestTimeLabel = $('#bestTimeLabel');
    const bestScoreLabel = $('#bestScoreLabel');
    const statusLine = $('#statusLine');

    const clearTime = $('#clearTime');
    const clearSteps = $('#clearSteps');
    const clearScore = $('#clearScore');
    const clearBest = $('#clearBest');
    const nextStageBtn = $('#nextStageBtn');
    const retryBtn = $('#retryBtn');
    const shareBtn = $('#shareBtn');

    const difficulties = {
      easy: { label: 'やさしい', size: 9, timeLimit: 60, stepLimit: 120, bonus: 200 },
      normal: { label: 'ふつう', size: 15, timeLimit: 90, stepLimit: 220, bonus: 500 },
      hard: { label: 'むずかしい', size: 21, timeLimit: 120, stepLimit: 350, bonus: 900 }
    };

    const colors = {
      start: '#38c172',
      goal: '#9966ff',
      ice: 'rgba(90, 200, 255, 0.35)',
      iceLine: '#4ec7ff',
      warp: '#ff7de9',
      oneway: '#ffbf66',
      crumble: '#d4b483',
      door: {
        gold: '#f5c542',
        blue: '#5ab0ff',
        red: '#ff5f6d'
      },
      key: {
        gold: '#ffd34d',
        blue: '#7cd3ff',
        red: '#ff7f88'
      }
    };

    const combos = { min: 1.0, step: 0.1, max: 1.5 };
    const stageCount = 10;

    const params = new URLSearchParams(location.search);
    const debugMode = params.get('debug') === '1';

    let animationHandle = 0;
    let pixelRatio = window.devicePixelRatio || 1;
    let tileSize = 0;
    let offsetX = 0;
    let offsetY = 0;

    const state = {
      grid: null,
      startCell: null,
      goalCell: null,
      current: null,
      pathCells: [],
      visitedCells: new Set(),
      visitedEdges: new Set(),
      difficulty: 'easy',
      stage: 1,
      stageSeed: '',
      customStage: false,
      timerStart: 0,
      elapsed: 0,
      steps: 0,
      score: 0,
      combo: loadCombo(),
      keyState: {},
      doorLookup: {},
      autoSliding: false,
      slideDir: null,
      pointerDown: false,
      runStarted: false,
      completed: false,
      failed: false,
      lastTick: performance.now(),
      warpCooldown: 0,
      stageInfo: null,
      bestTime: null,
      bestScore: null,
      stepLimit: 0,
      timeLimit: 0,
      difficultyBonus: 0
    };

    const particles = [];
    const audio = createAudio();
    muteBtn.textContent = audio.muted ? '🔇' : '🔊';
    muteBtn.setAttribute('aria-pressed', audio.muted ? 'true' : 'false');

    function loadCombo() {
      const v = parseFloat(localStorage.getItem('osm_combo'));
      if (!Number.isFinite(v)) return 1.0;
      return Math.min(Math.max(v, combos.min), combos.max);
    }

    function saveCombo(v) {
      localStorage.setItem('osm_combo', String(v.toFixed(2)));
    }

    function showToast(text, duration = 1800) {
      toastEl.textContent = text;
      toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), duration);
    }

    function hashString(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      return (h ^= h >>> 16) >>> 0;
    }

    function mulberry32(a) {
      return function () {
        let t = (a += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function rngFromSeed(seed) {
      const hashed = hashString(seed);
      const rand = mulberry32(hashed || 1);
      return {
        next: () => rand(),
        int: (max) => Math.floor(rand() * max),
        pick: (arr) => arr[Math.floor(rand() * arr.length)]
      };
    }

    function stageSeedKey(diff, index) {
      return hashString(`${diff}:${index}`);
    }

    function stageSeedString(diff, index) {
      return stageSeedKey(diff, index).toString(16).padStart(8, '0');
    }

    function buildStageList() {
      stageColumns.innerHTML = '';
      Object.entries(difficulties).forEach(([key, info]) => {
        const column = document.createElement('div');
        column.className = 'stage-column';
        const title = document.createElement('h2');
        title.textContent = info.label;
        column.appendChild(title);
        const buttonsWrap = document.createElement('div');
        buttonsWrap.className = 'stage-buttons';
        const unlock = getUnlocked(key);
        for (let i = 1; i <= stageCount; i++) {
          const btn = document.createElement('button');
          btn.textContent = i;
          btn.dataset.difficulty = key;
          btn.dataset.stage = String(i);
          if (i > unlock) {
            btn.disabled = true;
            btn.classList.add('locked');
          } else {
            btn.addEventListener('click', () => {
              homeOverlay.classList.add('hidden');
              startStage({ difficulty: key, stage: i, seed: stageSeedString(key, i), custom: false });
            });
          }
          buttonsWrap.appendChild(btn);
        }
        column.appendChild(buttonsWrap);
        stageColumns.appendChild(column);
      });
    }

    function getUnlocked(diff) {
      const key = `osm_unlock_${diff}`;
      const value = parseInt(localStorage.getItem(key), 10);
      if (!Number.isFinite(value)) {
        localStorage.setItem(key, '1');
        return 1;
      }
      return Math.min(Math.max(value, 1), stageCount);
    }

    function setUnlocked(diff, value) {
      localStorage.setItem(`osm_unlock_${diff}`, String(Math.min(value, stageCount)));
    }

    function createGrid(size) {
      return Array.from({ length: size }, (_, r) =>
        Array.from({ length: size }, (_, c) => ({
          r,
          c,
          walls: { N: true, E: true, S: true, W: true },
          type: 'normal',
          meta: {},
          special: null
        }))
      );
    }

    function carveMaze(grid, rng) {
      const stack = [];
      const visited = new Set();
      const start = grid[0][0];
      stack.push(start);
      visited.add('0,0');
      const dirs = [
        { dr: -1, dc: 0, wall: 'N', opp: 'S' },
        { dr: 0, dc: 1, wall: 'E', opp: 'W' },
        { dr: 1, dc: 0, wall: 'S', opp: 'N' },
        { dr: 0, dc: -1, wall: 'W', opp: 'E' }
      ];

      while (stack.length) {
        const current = stack[stack.length - 1];
        const neighbors = dirs
          .map((dir) => ({ dir, cell: cellAt(grid, current.r + dir.dr, current.c + dir.dc) }))
          .filter(({ cell }) => cell && !visited.has(`${cell.r},${cell.c}`));
        if (neighbors.length === 0) {
          stack.pop();
        } else {
          const { dir, cell } = neighbors[rng.int(neighbors.length)];
          current.walls[dir.wall] = false;
          cell.walls[dir.opp] = false;
          visited.add(`${cell.r},${cell.c}`);
          stack.push(cell);
        }
      }
    }

    function cellAt(grid, r, c) {
      if (!grid) return null;
      if (r < 0 || c < 0 || r >= grid.length || c >= grid.length) return null;
      return grid[r][c];
    }

    function findPath(grid, startCell, goalCell) {
      const visited = new Set();
      const path = [];
      const dirs = [
        { dr: -1, dc: 0, wall: 'N' },
        { dr: 0, dc: 1, wall: 'E' },
        { dr: 1, dc: 0, wall: 'S' },
        { dr: 0, dc: -1, wall: 'W' }
      ];

      function dfs(cell) {
        path.push(cell);
        if (cell === goalCell) return true;
        visited.add(`${cell.r},${cell.c}`);
        for (const dir of dirs) {
          if (cell.walls[dir.wall]) continue;
          const next = cellAt(grid, cell.r + dir.dr, cell.c + dir.dc);
          if (!next || visited.has(`${next.r},${next.c}`)) continue;
          if (dfs(next)) return true;
        }
        path.pop();
        return false;
      }
      dfs(startCell);
      return path.slice();
    }

    function directionBetween(a, b) {
      const dr = b.r - a.r;
      const dc = b.c - a.c;
      if (dr === -1 && dc === 0) return 'N';
      if (dr === 1 && dc === 0) return 'S';
      if (dr === 0 && dc === -1) return 'W';
      if (dr === 0 && dc === 1) return 'E';
      return null;
    }

    function applyGimmicks(grid, path, rng, difficultyKey) {
      const startCell = path[0];
      const goalCell = path[path.length - 1];
      startCell.special = 'start';
      goalCell.special = 'goal';

      const avoid = new Set(path.map((cell) => `${cell.r},${cell.c}`));

      const colorsOrder = ['gold', 'blue', 'red'];
      const color = colorsOrder[rng.int(colorsOrder.length)];
      const doorIdx = Math.max(2, Math.min(path.length - 2, Math.floor(path.length * 0.65)));
      const keyIdx = Math.max(1, Math.floor(doorIdx * 0.5));
      const doorCell = path[doorIdx];
      const keyCell = path[keyIdx];
      if (doorCell && keyCell) {
        doorCell.type = 'door';
        doorCell.meta = { color, locked: true };
        keyCell.type = 'key';
        keyCell.meta = { color };
      }

      const onewayCount = difficultyKey === 'hard' ? 4 : difficultyKey === 'normal' ? 3 : 2;
      const usedIndices = new Set([0, path.length - 1, keyIdx, doorIdx]);
      for (let i = 0; i < onewayCount; i++) {
        let idx = Math.floor(path.length * (0.2 + 0.6 * rng.next()));
        let safety = 0;
        while ((usedIndices.has(idx) || idx <= 1 || idx >= path.length - 2) && safety++ < 40) {
          idx = Math.floor(path.length * rng.next());
        }
        if (usedIndices.has(idx) || idx <= 1 || idx >= path.length - 1) continue;
        usedIndices.add(idx);
        const cell = path[idx];
        if (!cell || cell.type !== 'normal') continue;
        const dir = directionBetween(path[idx - 1], cell);
        const dirOut = directionBetween(cell, path[idx + 1]) || dir;
        cell.type = 'oneway';
        cell.meta = { dirIn: dir, dirOut };
      }

      const straightSegments = [];
      for (let i = 1; i < path.length - 1; i++) {
        const dir1 = directionBetween(path[i - 1], path[i]);
        const dir2 = directionBetween(path[i], path[i + 1]);
        if (dir1 && dir1 === dir2) {
          straightSegments.push({ index: i, dir: dir1 });
        }
      }
      const iceCount = difficultyKey === 'hard' ? 4 : difficultyKey === 'normal' ? 3 : 2;
      const iceUsed = new Set([keyIdx, doorIdx]);
      for (let i = 0; i < iceCount && straightSegments.length; i++) {
        const pick = straightSegments.splice(rng.int(straightSegments.length), 1)[0];
        if (!pick) continue;
        let idx = pick.index;
        if (iceUsed.has(idx)) continue;
        const dir = pick.dir;
        let len = 1 + rng.int(2);
        let j = 0;
        while (j < len && idx + j < path.length - 1) {
          const target = path[idx + j];
          if (!target || target.type !== 'normal') break;
          target.type = 'ice';
          target.meta = { dir };
          iceUsed.add(idx + j);
          j++;
        }
      }

      const warpPairs = Math.min(1 + (difficultyKey === 'hard' ? 1 : 0), Math.floor(path.length / 6));
      const warpList = [];
      for (let p = 0; p < warpPairs; p++) {
        const idxA = Math.max(2, Math.floor(path.length * (0.15 + rng.next() * 0.3)));
        const idxB = Math.max(idxA + 3, Math.floor(path.length * (0.55 + rng.next() * 0.35)));
        const cellA = path[idxA];
        const cellB = path[Math.min(path.length - 2, idxB)];
        if (!cellA || !cellB || cellA === cellB) continue;
        if (cellA.type !== 'normal' || cellB.type !== 'normal') continue;
        const warpId = `warp-${p}-${rng.int(9999)}`;
        cellA.type = 'warp';
        cellA.meta = { id: warpId };
        cellB.type = 'warp';
        cellB.meta = { id: warpId };
        warpList.push({ id: warpId, a: cellA, b: cellB });
      }
      warpList.forEach(({ a, b }) => {
        a.meta.pair = b;
        b.meta.pair = a;
      });

      const branchCells = [];
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid.length; c++) {
          const cell = grid[r][c];
          const key = `${r},${c}`;
          if (avoid.has(key)) continue;
          const degree = neighborCells(grid, cell).length;
          if (degree <= 1) branchCells.push(cell);
        }
      }
      const crumbleCount = Math.min(branchCells.length, difficultyKey === 'hard' ? 8 : difficultyKey === 'normal' ? 6 : 4);
      for (let i = 0; i < crumbleCount; i++) {
        const cell = branchCells.splice(rng.int(branchCells.length), 1)[0];
        if (!cell) break;
        cell.type = 'crumble';
        cell.meta = { collapsed: false };
      }

      return { startCell, goalCell, doorCell, keyCell };
    }

    function neighborCells(grid, cell) {
      const dirs = [
        { dr: -1, dc: 0, wall: 'N' },
        { dr: 0, dc: 1, wall: 'E' },
        { dr: 1, dc: 0, wall: 'S' },
        { dr: 0, dc: -1, wall: 'W' }
      ];
      const result = [];
      for (const dir of dirs) {
        if (cell.walls[dir.wall]) continue;
        const next = cellAt(grid, cell.r + dir.dr, cell.c + dir.dc);
        if (next) result.push({ cell: next, dir: dir.wall });
      }
      return result;
    }

    function posToCell(x, y) {
      const rect = canvas.getBoundingClientRect();
      const px = x - rect.left;
      const py = y - rect.top;
      const col = Math.floor((px - offsetX) / tileSize);
      const row = Math.floor((py - offsetY) / tileSize);
      if (Number.isNaN(row) || Number.isNaN(col)) return null;
      if (!state.grid || row < 0 || col < 0 || row >= state.grid.length || col >= state.grid.length) return null;
      return state.grid[row][col];
    }

    function centerOf(cell) {
      return [offsetX + (cell.c + 0.5) * tileSize, offsetY + (cell.r + 0.5) * tileSize];
    }

    function keyFor(cell) {
      return `${cell.r},${cell.c}`;
    }

    function edgeKey(a, b) {
      return a.r < b.r || (a.r === b.r && a.c < b.c) ? `${keyFor(a)}|${keyFor(b)}` : `${keyFor(b)}|${keyFor(a)}`;
    }

    function resetState() {
      state.pathCells = [];
      state.visitedCells.clear();
      state.visitedEdges.clear();
      state.steps = 0;
      state.elapsed = 0;
      state.timerStart = 0;
      state.runStarted = false;
      state.autoSliding = false;
      state.slideDir = null;
      state.pointerDown = false;
      state.completed = false;
      state.failed = false;
      state.warpCooldown = 0;
      state.keyState = {};
      state.score = 0;
      if (state.grid) {
        for (let r = 0; r < state.grid.length; r++) {
          for (let c = 0; c < state.grid.length; c++) {
            const cell = state.grid[r][c];
            if (cell.type === 'crumble' && cell.meta) {
              cell.meta.collapsed = false;
            }
          }
        }
      }
      Object.values(state.doorLookup || {}).forEach((door) => {
        if (door && door.meta) {
          door.type = 'door';
          door.meta.locked = true;
          door.meta.opened = false;
        }
      });
      particles.length = 0;
      if (state.startCell) {
        state.current = state.startCell;
        state.pathCells.push(state.startCell);
        state.visitedCells.add(keyFor(state.startCell));
      }
      updateHUD();
    }

    function startStage({ difficulty, stage, seed, custom }) {
      state.difficulty = difficulty;
      difficultySelect.value = difficulty;
      state.stage = typeof stage === 'number' ? stage : 1;
      state.stageSeed = seed || stageSeedString(difficulty, state.stage);
      state.customStage = Boolean(custom);
      const info = difficulties[difficulty];
      state.timeLimit = info.timeLimit;
      state.stepLimit = info.stepLimit;
      state.difficultyBonus = info.bonus;
      state.stageInfo = info;

      const rng = rngFromSeed(state.stageSeed);
      const size = info.size;
      const grid = createGrid(size);
      carveMaze(grid, rng);
      const path = findPath(grid, grid[0][0], grid[size - 1][size - 1]);
      const { startCell, goalCell, doorCell } = applyGimmicks(grid, path, rng, difficulty);
      state.grid = grid;
      state.startCell = startCell;
      state.goalCell = goalCell;
      state.doorLookup = {};
      if (doorCell && doorCell.meta) {
        state.doorLookup[doorCell.meta.color] = doorCell;
      }
      state.bestTime = loadBest('time');
      state.bestScore = loadBest('score');
      resetState();
      resize();
      updateURL();
      const stageText = state.customStage ? 'カスタム' : `ステージ ${state.stage}`;
      statusLine.textContent = `${info.label} ${stageText} | シード ${state.stageSeed}`;
      localStorage.setItem('osm_continue', JSON.stringify({ difficulty, stage: state.stage, seed: state.stageSeed, custom: !!custom }));
      updateMenuContinue();
      hideOverlays();
      playSound('start');
    }

    function updateURL() {
      const params = new URLSearchParams(location.search);
      params.set('difficulty', state.difficulty);
      params.set('seed', state.stageSeed);
      params.set('stage', String(state.stage));
      if (debugMode) params.set('debug', '1');
      history.replaceState(null, '', `${location.pathname}?${params.toString()}`);
    }

    function hideOverlays() {
      homeOverlay.classList.add('hidden');
      clearOverlay.classList.add('hidden');
      howToModal.classList.add('hidden');
    }

    function loadBest(kind) {
      const key = state.customStage ? `osm_best_${kind}_${state.stageSeed}` : `osm_best_${kind}_${state.difficulty}_${state.stage}`;
      const value = parseFloat(localStorage.getItem(key));
      if (!Number.isFinite(value)) return null;
      return value;
    }

    function saveBest(kind, value) {
      const key = state.customStage ? `osm_best_${kind}_${state.stageSeed}` : `osm_best_${kind}_${state.difficulty}_${state.stage}`;
      localStorage.setItem(key, String(value));
    }

    function formatTime(value) {
      if (!Number.isFinite(value)) return '--';
      return value.toFixed(2) + 's';
    }

    function updateHUD() {
      timeLabel.textContent = formatTime(state.elapsed);
      stepsLabel.textContent = state.steps.toString();
      const remainTime = Math.max(0, state.timeLimit - state.elapsed);
      timeRemainLabel.textContent = formatTime(remainTime);
      stepsRemainLabel.textContent = Math.max(0, state.stepLimit - state.steps).toString();
      scoreLabel.textContent = Math.round(state.score).toString();
      comboLabel.textContent = `${state.combo.toFixed(1)}x`;
      bestTimeLabel.textContent = state.bestTime ? formatTime(state.bestTime) : '--';
      bestScoreLabel.textContent = state.bestScore ? Math.round(state.bestScore).toString() : '--';
    }

    function pointerDown(event) {
      event.preventDefault();
      if (!state.grid || state.completed || state.failed) return;
      state.pointerDown = true;
      canvas.setPointerCapture(event.pointerId);
      const cell = posToCell(event.clientX, event.clientY);
      if (!cell) return;
      if (cell !== state.startCell && !state.runStarted) {
        state.pointerDown = false;
        return;
      }
      if (!state.runStarted) {
        state.runStarted = true;
        state.timerStart = performance.now();
        state.elapsed = 0;
        state.pathCells = [state.startCell];
        state.visitedCells = new Set([keyFor(state.startCell)]);
        state.visitedEdges = new Set();
        state.current = state.startCell;
        state.autoSliding = false;
        state.score = 0;
      }
      handlePointerMove(event);
    }

    function pointerMove(event) {
      if (!state.pointerDown || state.completed || state.failed) return;
      handlePointerMove(event);
    }

    function handlePointerMove(event) {
      if (!state.runStarted || state.autoSliding) return;
      const cell = posToCell(event.clientX, event.clientY);
      if (!cell || cell === state.current) return;
      attemptMove(cell, { auto: false, dir: directionBetween(state.current, cell) });
    }

    function pointerUp(event) {
      if (!state.pointerDown) return;
      state.pointerDown = false;
      if (canvas.hasPointerCapture(event.pointerId)) {
        canvas.releasePointerCapture(event.pointerId);
      }
      if (!state.completed) {
        fail('指を離しました');
      }
    }

    function keyHandler(event) {
      if (event.repeat) return;
      if (event.key === 'Escape') {
        if (document.body.classList.contains('menu-active')) return;
        if (state.grid) fail('リセット');
      } else if ((event.key === 'Enter' || event.key === ' ') && !document.body.classList.contains('menu-active')) {
        if (!state.runStarted && !homeOverlay.classList.contains('hidden')) {
          const data = getContinueData();
          if (data) startStage(data);
          else startStage({ difficulty: difficultySelect.value, stage: 1, seed: stageSeedString(difficultySelect.value, 1), custom: false });
        }
      }
    }

    function attemptMove(target, context = { auto: false, dir: null }) {
      const current = state.current;
      if (!current || target === current) return;
      const dr = target.r - current.r;
      const dc = target.c - current.c;
      if (Math.abs(dr) + Math.abs(dc) !== 1) return;
      const dir = dr === -1 ? 'N' : dr === 1 ? 'S' : dc === -1 ? 'W' : 'E';
      if (current.walls[dir]) {
        if (context.auto) {
          state.autoSliding = false;
          return;
        }
        fail('壁にぶつかりました');
        return;
      }
      if (!canEnter(current, target, dir)) {
        if (context.auto) {
          state.autoSliding = false;
          return;
        }
        fail('通れません');
        return;
      }
      const key = keyFor(target);
      if (state.visitedCells.has(key)) {
        fail('同じマスは通れません');
        return;
      }
      const eKey = edgeKey(current, target);
      if (state.visitedEdges.has(eKey)) {
        fail('同じ道は通れません');
        return;
      }
      applyMove(current, target, dir, context);
    }

    function canEnter(from, to, dir) {
      if (to.type === 'door' && to.meta.locked) return false;
      if (to.type === 'crumble' && to.meta.collapsed) return false;
      if (to.type === 'oneway') {
        const allowed = to.meta.dirIn;
        if (allowed && allowed !== dir) return false;
      }
      return true;
    }

    function applyMove(from, to, dir, context) {
      state.current = to;
      state.visitedCells.add(keyFor(to));
      state.visitedEdges.add(edgeKey(from, to));
      state.pathCells.push(to);
      state.steps += 1;
      playSound('move');
      checkLimits();
      handleTile(from, to, dir, context);
      updateHUD();
    }

    function handleTile(from, to, dir, context) {
      if (from.type === 'crumble' && !from.meta.collapsed) {
        from.meta.collapsed = true;
      }
      if (to === state.goalCell) {
        complete();
        return;
      }
      switch (to.type) {
        case 'key':
          collectKey(to.meta.color);
          break;
        case 'warp':
          triggerWarp(to, dir);
          break;
        case 'ice':
          state.autoSliding = true;
          state.slideDir = dir;
          break;
        default:
          state.autoSliding = false;
          state.slideDir = null;
          break;
      }
    }

    function collectKey(color) {
      if (state.keyState[color]) return;
      playSound('key');
      state.keyState[color] = true;
      const doorCell = state.doorLookup[color];
      if (doorCell) {
        doorCell.type = 'normal';
        doorCell.meta.locked = false;
        doorCell.meta.opened = true;
      }
      showToast(`${colorName(color)}の鍵を入手！`);
    }

    function triggerWarp(cell, dir) {
      if (!cell.meta.pair || state.warpCooldown > 0) return;
      playSound('warp');
      const target = cell.meta.pair;
      if (state.visitedCells.has(keyFor(target))) {
        fail('ワープ先は通れません');
        return;
      }
      state.warpCooldown = 2;
      state.current = target;
      state.visitedCells.add(keyFor(target));
      state.pathCells.push(target);
      if (target === state.goalCell) {
        complete();
        return;
      }
      if (target.type === 'key') {
        collectKey(target.meta.color);
      }
      if (target.type === 'ice') {
        state.autoSliding = true;
        state.slideDir = dir || directionBetween(cell, target) || 'N';
      } else {
        state.autoSliding = false;
        state.slideDir = null;
      }
    }

    function colorName(color) {
      switch (color) {
        case 'gold':
          return '金';
        case 'blue':
          return '青';
        case 'red':
          return '赤';
        default:
          return color;
      }
    }

    function checkLimits() {
      if (state.steps > state.stepLimit) {
        fail('手数制限を超えました');
      }
    }

    function fail(reason) {
      if (state.failed) return;
      state.failed = true;
      state.autoSliding = false;
      state.pointerDown = false;
      state.combo = combos.min;
      saveCombo(state.combo);
      showToast(reason || '失敗');
      playSound('fail');
      setTimeout(() => {
        resetState();
        state.failed = false;
      }, 600);
    }

    function complete() {
      if (state.completed) return;
      state.completed = true;
      state.pointerDown = false;
      state.autoSliding = false;
      const now = performance.now();
      state.elapsed = ((now - state.timerStart) || 0) / 1000;
      const baseScore = Math.max(0, 10000 - state.elapsed * 100 - state.steps * 2 + state.difficultyBonus);
      let score = baseScore * state.combo;
      let bestBonus = false;
      if (!state.bestScore || score > state.bestScore) {
        score += 500;
        bestBonus = true;
      }
      state.score = Math.max(0, Math.round(score));
      if (!state.bestTime || state.elapsed < state.bestTime) {
        saveBest('time', state.elapsed);
        state.bestTime = state.elapsed;
        bestBonus = true;
      }
      if (!state.bestScore || state.score > state.bestScore) {
        saveBest('score', state.score);
        state.bestScore = state.score;
      }
      state.combo = Math.min(state.combo + combos.step, combos.max);
      saveCombo(state.combo);
      updateHUD();
      playSound('clear');
      spawnParticles(centerOf(state.goalCell));
      clearTime.textContent = formatTime(state.elapsed);
      clearSteps.textContent = state.steps.toString();
      clearScore.textContent = state.score.toString();
      clearBest.textContent = bestBonus ? 'Yes!' : 'No';
      clearOverlay.classList.remove('hidden');
      unlockNext();
    }

    function unlockNext() {
      if (state.customStage) return;
      const unlock = getUnlocked(state.difficulty);
      if (state.stage === unlock && state.stage < stageCount) {
        setUnlocked(state.difficulty, state.stage + 1);
        buildStageList();
      }
    }

    function spawnParticles([x, y]) {
      for (let i = 0; i < 26; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 120,
          vy: (Math.random() - 0.5) * 120,
          life: 600,
          age: 0,
          hue: 260 + Math.random() * 40
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.age += dt;
        if (p.age >= p.life) {
          particles.splice(i, 1);
          continue;
        }
        const t = dt / 1000;
        p.x += p.vx * t;
        p.y += p.vy * t;
        p.vy += 160 * t;
      }
    }

    function draw() {
      if (!state.grid) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      const { grid } = state;
      const size = grid.length;
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(10,13,20,0.95)';
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0, 0, tileSize * size, tileSize * size);
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          drawCellFloor(grid[r][c]);
        }
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = Math.max(1.5, tileSize * 0.08);
      ctx.beginPath();
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          drawCellWalls(grid[r][c]);
        }
      }
      ctx.stroke();
      ctx.restore();

      drawPath();
      drawParticles();

      if (debugMode) {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.font = `${Math.max(10, tileSize * 0.35)}px monospace`;
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const cell = grid[r][c];
            const [cx, cy] = centerOf(cell);
            ctx.fillText(cell.type[0], cx - tileSize * 0.15, cy + tileSize * 0.15);
          }
        }
        ctx.restore();
      }
      ctx.restore();
    }

    function drawCellFloor(cell) {
      const [x, y] = [cell.c * tileSize, cell.r * tileSize];
      const size = tileSize;
      ctx.save();
      if (cell.special === 'start') {
        ctx.fillStyle = colors.start;
        ctx.beginPath();
        ctx.arc(x + size / 2, y + size / 2, size * 0.28, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return;
      }
      if (cell.special === 'goal') {
        ctx.fillStyle = colors.goal;
        drawRoundedRect(x + 4, y + 4, size - 8, size - 8, Math.max(6, size * 0.2));
        ctx.fill();
        ctx.restore();
        return;
      }
      switch (cell.type) {
        case 'ice':
          ctx.fillStyle = colors.ice;
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          ctx.strokeStyle = colors.iceLine;
          ctx.lineWidth = Math.max(1, size * 0.05);
          ctx.beginPath();
          ctx.moveTo(x + size * 0.25, y + size * 0.25);
          ctx.lineTo(x + size * 0.75, y + size * 0.75);
          ctx.moveTo(x + size * 0.25, y + size * 0.75);
          ctx.lineTo(x + size * 0.75, y + size * 0.25);
          ctx.stroke();
          break;
        case 'warp':
          ctx.fillStyle = 'rgba(255, 125, 233, 0.25)';
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          ctx.strokeStyle = colors.warp;
          ctx.lineWidth = Math.max(1.5, size * 0.08);
          ctx.beginPath();
          ctx.arc(x + size / 2, y + size / 2, size * 0.25, 0, Math.PI * 2);
          ctx.stroke();
          break;
        case 'oneway':
          ctx.fillStyle = 'rgba(255, 191, 102, 0.35)';
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          drawArrow(cell.meta.dirIn, x, y, size);
          break;
        case 'key':
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          drawKey(cell.meta.color, x, y, size);
          break;
        case 'door':
          ctx.fillStyle = colors.door[cell.meta.color] || colors.door.gold;
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          ctx.strokeStyle = 'rgba(0,0,0,0.45)';
          ctx.lineWidth = Math.max(1, size * 0.05);
          ctx.beginPath();
          ctx.moveTo(x + size * 0.3, y + size * 0.2);
          ctx.lineTo(x + size * 0.7, y + size * 0.2);
          ctx.lineTo(x + size * 0.7, y + size * 0.8);
          ctx.lineTo(x + size * 0.3, y + size * 0.8);
          ctx.closePath();
          ctx.stroke();
          break;
        case 'crumble':
          ctx.fillStyle = cell.meta.collapsed ? 'rgba(80,60,30,0.4)' : 'rgba(212, 180, 131, 0.28)';
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          ctx.strokeStyle = 'rgba(80,60,30,0.6)';
          ctx.lineWidth = Math.max(1, size * 0.05);
          ctx.beginPath();
          ctx.moveTo(x + size * 0.2, y + size * 0.3);
          ctx.lineTo(x + size * 0.45, y + size * 0.55);
          ctx.lineTo(x + size * 0.3, y + size * 0.8);
          ctx.stroke();
          break;
        default:
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.fillRect(x + 3, y + 3, size - 6, size - 6);
          break;
      }
      ctx.restore();
    }

    function drawArrow(dir, x, y, size) {
      ctx.save();
      ctx.translate(x + size / 2, y + size / 2);
      const angle = dir === 'N' ? -Math.PI / 2 : dir === 'S' ? Math.PI / 2 : dir === 'E' ? 0 : Math.PI;
      ctx.rotate(angle);
      ctx.fillStyle = 'rgba(255, 210, 130, 0.9)';
      ctx.beginPath();
      ctx.moveTo(-size * 0.25, size * 0.15);
      ctx.lineTo(0, -size * 0.28);
      ctx.lineTo(size * 0.25, size * 0.15);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawKey(color, x, y, size) {
      ctx.strokeStyle = colors.key[color] || colors.key.gold;
      ctx.lineWidth = Math.max(1.5, size * 0.08);
      ctx.beginPath();
      ctx.arc(x + size * 0.4, y + size * 0.5, size * 0.18, 0, Math.PI * 2);
      ctx.moveTo(x + size * 0.4, y + size * 0.5);
      ctx.lineTo(x + size * 0.7, y + size * 0.5);
      ctx.moveTo(x + size * 0.64, y + size * 0.45);
      ctx.lineTo(x + size * 0.64, y + size * 0.58);
      ctx.stroke();
    }

    function drawCellWalls(cell) {
      const x = cell.c * tileSize;
      const y = cell.r * tileSize;
      const s = tileSize;
      if (cell.walls.N) {
        ctx.moveTo(x, y);
        ctx.lineTo(x + s, y);
      }
      if (cell.walls.S) {
        ctx.moveTo(x, y + s);
        ctx.lineTo(x + s, y + s);
      }
      if (cell.walls.W) {
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + s);
      }
      if (cell.walls.E) {
        ctx.moveTo(x + s, y);
        ctx.lineTo(x + s, y + s);
      }
    }

    function drawPath() {
      if (state.pathCells.length < 2) return;
      ctx.save();
      ctx.shadowColor = 'rgba(100, 200, 255, 0.7)';
      ctx.shadowBlur = Math.max(8, tileSize * 0.4);
      ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
      ctx.lineWidth = Math.max(6, tileSize * 0.2);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      const [sx, sy] = centerOf(state.pathCells[0]);
      ctx.moveTo(sx, sy);
      for (let i = 1; i < state.pathCells.length; i++) {
        const [x, y] = centerOf(state.pathCells[i]);
        ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawParticles() {
      ctx.save();
      for (const p of particles) {
        const alpha = Math.max(0, 1 - p.age / p.life);
        ctx.fillStyle = `hsla(${p.hue.toFixed(1)}, 80%, 60%, ${alpha.toFixed(2)})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(2, tileSize * 0.12) * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawRoundedRect(x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function resize() {
      const rect = shell.getBoundingClientRect();
      pixelRatio = window.devicePixelRatio || 1;
      canvas.width = Math.floor(rect.width * pixelRatio);
      canvas.height = Math.floor(rect.height * pixelRatio);
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      if (state.grid) {
        const size = state.grid.length;
        tileSize = Math.min(rect.width, rect.height) / size;
        const drawSize = tileSize * size;
        offsetX = Math.max(0, (rect.width - drawSize) / 2);
        offsetY = Math.max(0, (rect.height - drawSize) / 2);
      }
    }

    const observer = new ResizeObserver(() => {
      resize();
      draw();
    });
    observer.observe(shell);

    function loop(now) {
      animationHandle = requestAnimationFrame(loop);
      const dt = now - state.lastTick;
      state.lastTick = now;
      if (state.runStarted && !state.completed && !state.failed) {
        state.elapsed = (now - state.timerStart) / 1000;
        if (state.elapsed >= state.timeLimit) {
          fail('時間切れ');
        }
        if (state.autoSliding) {
          const dir = state.slideDir;
          const current = state.current;
          const next = neighborByDir(current, dir);
          if (!next || current.walls[dir] || state.visitedCells.has(keyFor(next)) || !canEnter(current, next, dir)) {
            state.autoSliding = false;
          } else {
            attemptMove(next, { auto: true, dir });
          }
        }
      }
      updateParticles(dt);
      updateHUD();
      draw();
    }

    function neighborByDir(cell, dir) {
      if (!cell) return null;
      switch (dir) {
        case 'N':
          return cellAt(state.grid, cell.r - 1, cell.c);
        case 'S':
          return cellAt(state.grid, cell.r + 1, cell.c);
        case 'W':
          return cellAt(state.grid, cell.r, cell.c - 1);
        case 'E':
          return cellAt(state.grid, cell.r, cell.c + 1);
        default:
          return null;
      }
    }

    function getContinueData() {
      try {
        const data = JSON.parse(localStorage.getItem('osm_continue'));
        if (!data) return null;
        if (!difficulties[data.difficulty]) return null;
        return data;
      } catch (err) {
        return null;
      }
    }

    function updateMenuContinue() {
      if (!menuContinueBtn) return;
      const hasData = !!getContinueData();
      menuContinueBtn.disabled = !hasData;
      if (hasData) {
        menuContinueBtn.removeAttribute('aria-disabled');
      } else {
        menuContinueBtn.setAttribute('aria-disabled', 'true');
      }
    }

    function showMenu() {
      document.body.classList.remove('maze-active');
      document.body.classList.remove('shooter-active');
      document.body.classList.add('menu-active');
      if (menuScreen) {
        menuScreen.setAttribute('aria-hidden', 'false');
      }
      if (shooterApp) {
        shooterApp.setAttribute('aria-hidden', 'true');
      }
      updateMenuContinue();
      document.dispatchEvent(new CustomEvent('minigame:menu'));
    }

    function enterMaze({ autoStart = false } = {}) {
      document.body.classList.add('maze-active');
      document.body.classList.remove('menu-active');
      document.body.classList.remove('shooter-active');
      if (menuScreen) {
        menuScreen.setAttribute('aria-hidden', 'true');
      }
      if (shooterApp) {
        shooterApp.setAttribute('aria-hidden', 'true');
      }
      clearOverlay.classList.add('hidden');
      howToModal.classList.add('hidden');
      if (!autoStart) {
        homeOverlay.classList.remove('hidden');
      }
    }

    function returnToMenu() {
      hideOverlays();
      resetState();
      showMenu();
    }

    function setupEvents() {
      canvas.addEventListener('pointerdown', pointerDown);
      window.addEventListener('pointermove', pointerMove);
      window.addEventListener('pointerup', pointerUp);
      window.addEventListener('pointercancel', pointerUp);
      window.addEventListener('keydown', keyHandler);

      if (menuStartBtn) {
        menuStartBtn.addEventListener('click', () => {
          enterMaze({ autoStart: false });
        });
      }

      if (menuContinueBtn) {
        menuContinueBtn.addEventListener('click', () => {
          const data = getContinueData();
          if (data) {
            enterMaze({ autoStart: true });
            startStage(data);
          } else {
            enterMaze({ autoStart: false });
            showToast('続きはありません');
          }
        });
      }

      if (menuReturnBtn) {
        menuReturnBtn.addEventListener('click', () => {
          returnToMenu();
        });
      }

      newGameBtn.addEventListener('click', () => {
        const diff = difficultySelect.value;
        const seed = Math.random().toString(36).slice(2, 10);
        startStage({ difficulty: diff, stage: 0, seed, custom: true });
      });

      levelSelectBtn.addEventListener('click', () => {
        homeOverlay.classList.remove('hidden');
      });

      howToBtn.addEventListener('click', () => {
        howToModal.classList.remove('hidden');
      });

      howToCloseBtn.addEventListener('click', () => {
        howToModal.classList.add('hidden');
      });

      muteBtn.addEventListener('click', () => {
        audio.toggle();
        muteBtn.textContent = audio.muted ? '🔇' : '🔊';
        muteBtn.setAttribute('aria-pressed', audio.muted ? 'true' : 'false');
      });

      continueBtn.addEventListener('click', () => {
        const data = getContinueData();
        if (data) startStage(data);
        else showToast('続きはありません');
      });

      randomBtn.addEventListener('click', () => {
        const diff = difficultySelect.value;
        const seed = Math.random().toString(36).slice(2, 10);
        startStage({ difficulty: diff, stage: 0, seed, custom: true });
      });

      seedCopyBtn.addEventListener('click', () => {
        copyText(`${location.origin}${location.pathname}?seed=${state.stageSeed}&difficulty=${state.difficulty}&stage=${state.stage}`);
      });

      seedStartBtn.addEventListener('click', () => {
        const seed = seedInput.value.trim() || Math.random().toString(36).slice(2, 10);
        const diff = seedDifficulty.value;
        const stage = Math.max(1, Math.min(stageCount, Number(seedStage.value) || 1));
        startStage({ difficulty: diff, stage, seed, custom: true });
      });

      nextStageBtn.addEventListener('click', () => {
        if (state.customStage) {
          startStage({ difficulty: state.difficulty, stage: 0, seed: Math.random().toString(36).slice(2, 10), custom: true });
        } else {
          const nextStage = Math.min(stageCount, state.stage + 1);
          startStage({ difficulty: state.difficulty, stage: nextStage, seed: stageSeedString(state.difficulty, nextStage), custom: false });
        }
      });

      retryBtn.addEventListener('click', () => {
        startStage({ difficulty: state.difficulty, stage: state.stage, seed: state.stageSeed, custom: state.customStage });
      });

      shareBtn.addEventListener('click', shareStage);
    }

    function shareStage() {
      const stageLabel = state.customStage ? 'カスタム' : `ステージ${state.stage}`;
      const url = `${location.origin}${location.pathname}?seed=${state.stageSeed}&difficulty=${state.difficulty}&stage=${state.stage}`;
      const text = `一筆書き迷路 ${difficulties[state.difficulty].label} ${stageLabel} - シード:${state.stageSeed}`;
      if (navigator.share) {
        navigator.share({ title: '一筆書き迷路', text, url }).catch(() => copyText(url));
      } else {
        copyText(url);
      }
    }

    function copyText(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => showToast('URLをコピーしました')).catch(() => showToast('コピーできませんでした'));
      } else {
        showToast('クリップボードに対応していません');
      }
    }

    function initFromQuery({ autoStart = false } = {}) {
      const diffParam = params.get('difficulty');
      const stageParam = parseInt(params.get('stage'), 10);
      const seedParam = params.get('seed');
      const difficulty = diffParam && difficulties[diffParam] ? diffParam : 'easy';
      const stage = Number.isFinite(stageParam) ? stageParam : 1;
      difficultySelect.value = difficulty;
      seedDifficulty.value = difficulty;
      seedStage.value = String(Math.max(1, stage));
      seedInput.value = seedParam ? seedParam : '';
      if (!autoStart) return;
      if (seedParam) {
        startStage({ difficulty, stage, seed: seedParam, custom: true });
      } else {
        startStage({ difficulty, stage, seed: stageSeedString(difficulty, stage), custom: false });
      }
    }

    function createAudio() {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctxAudio = AudioContext ? new AudioContext() : null;
      let muted = localStorage.getItem('osm_muted') === '1';
      let unlocked = false;
      if (ctxAudio) {
        const resume = () => {
          if (!unlocked) {
            ctxAudio.resume();
            unlocked = true;
          }
        };
        window.addEventListener('pointerdown', resume, { once: true });
      }
      function play(type) {
        if (!ctxAudio || muted) return;
        const now = ctxAudio.currentTime;
        const osc = ctxAudio.createOscillator();
        const gain = ctxAudio.createGain();
        osc.type = type === 'clear' ? 'triangle' : type === 'fail' ? 'sawtooth' : 'sine';
        const freq = type === 'key' ? 720 : type === 'warp' ? 440 : type === 'clear' ? 620 : type === 'fail' ? 140 : 280;
        osc.frequency.setValueAtTime(freq, now);
        gain.gain.setValueAtTime(0.001, now);
        gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
        osc.connect(gain).connect(ctxAudio.destination);
        osc.start(now);
        osc.stop(now + 0.4);
      }
      return {
        play,
        toggle() {
          muted = !muted;
          localStorage.setItem('osm_muted', muted ? '1' : '0');
        },
        get muted() {
          return muted;
        }
      };
    }

    function playSound(name) {
      audio.play(name);
    }

    function start() {
      buildStageList();
      setupEvents();
      resize();
      const shouldAutoStart = params.has('seed') || params.has('difficulty') || params.has('stage');
      if (shouldAutoStart) {
        enterMaze({ autoStart: true });
        initFromQuery({ autoStart: true });
      } else {
        showMenu();
        initFromQuery({ autoStart: false });
      }
      animationHandle = requestAnimationFrame(loop);
    }

    start();
    if (typeof window !== 'undefined') {
      const api = window.miniGameMenu || {};
      api.showMenu = showMenu;
      api.enterMaze = enterMaze;
      window.miniGameMenu = api;
    }
  })();
  </script>
  <script>
  (() => {
    const root = document.getElementById('shooterApp');
    if (!root) return;

    const canvas = document.getElementById('shooterCanvas');
    const ctx = canvas.getContext('2d');
    const shell = document.getElementById('shooterCanvasShell');
    const startOverlay = document.getElementById('shooterStartOverlay');
    const gameOverOverlay = document.getElementById('shooterGameOverOverlay');
    const toast = document.getElementById('shooterToast');
    const menuBtn = document.getElementById('shooterMenuBtn');
    const menuFromResultBtn = document.getElementById('shooterMenuFromResultBtn');
    const bombBtn = document.getElementById('shooterBombBtn');
    const muteBtn = document.getElementById('shooterMuteBtn');
    const difficultySelect = document.getElementById('shooterDifficulty');
    const modeButtons = root.querySelectorAll('[data-mode-select]');
    const startButtons = root.querySelectorAll('[data-start-mode]');
    const retryBtn = document.getElementById('shooterRetryBtn');
    const modeSelectBtn = document.getElementById('shooterModeSelectBtn');
    const menuScoreBtn = document.getElementById('menuShooterScoreBtn');
    const menuSurvivalBtn = document.getElementById('menuShooterSurvivalBtn');

    const scoreLabel = document.getElementById('shooterScoreLabel');
    const timerLabel = document.getElementById('shooterTimerLabel');
    const hpLabel = document.getElementById('shooterHpLabel');
    const bombLabel = document.getElementById('shooterBombLabel');
    const shieldLabel = document.getElementById('shooterShieldLabel');
    const chainLabel = document.getElementById('shooterChainLabel');
    const bestLabel = document.getElementById('shooterBestLabel');
    const finalScoreLabel = document.getElementById('shooterFinalScore');
    const bestScoreLabel = document.getElementById('shooterBestScore');
    const gameOverTitle = document.getElementById('shooterGameOverTitle');

    let width = 0;
    let height = 0;
    let pixelRatio = window.devicePixelRatio || 1;
    let backgroundGradient = null;
    let lastFrame = performance.now();

    const difficultySettings = {
      easy: { spawnInterval: 1.4, speed: 0.9, bulletSpeed: 0.85, bulletDensity: 0.85, bombs: 3, hp: 4, chipValue: 90, score: 1.0 },
      normal: { spawnInterval: 1.1, speed: 1.0, bulletSpeed: 1.0, bulletDensity: 1.0, bombs: 2, hp: 3, chipValue: 120, score: 1.15 },
      hard: { spawnInterval: 0.85, speed: 1.2, bulletSpeed: 1.25, bulletDensity: 1.25, bombs: 2, hp: 3, chipValue: 150, score: 1.35 }
    };

    const state = {
      active: false,
      running: false,
      mode: 'score',
      difficulty: difficultySelect ? difficultySelect.value : 'normal',
      bombs: 0,
      shield: 0,
      hp: 3,
      timer: 60,
      elapsed: 0,
      realTime: 0,
      spawnTimer: 0,
      score: 0,
      chainCount: 0,
      chainTimer: 0,
      chainMultiplier: 1,
      slowMoTimer: 0,
      timeScale: 1,
      bombCooldown: 0,
      bestScore: 0,
      config: null,
      resultMessage: ''
    };

    const player = {
      x: 0,
      y: 0,
      radius: 12,
      speed: 320,
      fireCooldown: 0,
      fireDelay: 0.12,
      pointerActive: false,
      targetX: 0,
      targetY: 0,
      invincible: 0
    };

    const keyState = Object.create(null);
    const bullets = [];
    const enemies = [];
    const enemyBullets = [];
    const items = [];
    const particles = [];
    const floatingTexts = [];
    const formations = new Map();
    let nextFormationId = 1;

    const stars = [];
    const STAR_COUNT = 90;

    const screenShake = { power: 0, duration: 0, time: 0 };
    let toastTimer = 0;
    let activePointerId = null;

    const audio = createShooterAudio();
    updateMuteButton();

    state.config = difficultySettings[state.difficulty] || difficultySettings.normal;

    setupEvents();
    resize();
    draw();
    requestAnimationFrame(loop);

    setMode(state.mode);
    setDifficulty(state.difficulty);
    updateBestLabel();
    updateHUD();
    function setupEvents() {
      if (menuScoreBtn) {
        menuScoreBtn.addEventListener('click', () => openShooter('score'));
      }
      if (menuSurvivalBtn) {
        menuSurvivalBtn.addEventListener('click', () => openShooter('survival'));
      }
      if (menuBtn) {
        menuBtn.addEventListener('click', () => goToMenu());
      }
      if (menuFromResultBtn) {
        menuFromResultBtn.addEventListener('click', () => goToMenu());
      }
      if (retryBtn) {
        retryBtn.addEventListener('click', () => startGame(state.mode));
      }
      if (modeSelectBtn) {
        modeSelectBtn.addEventListener('click', () => showModeSelect());
      }
      modeButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.getAttribute('data-mode-select');
          setMode(mode);
          if (!state.running) updateHUD();
        });
      });
      startButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.getAttribute('data-start-mode');
          startGame(mode);
        });
      });
      if (bombBtn) {
        bombBtn.addEventListener('click', () => useBomb());
      }
      if (muteBtn) {
        muteBtn.addEventListener('click', () => {
          audio.toggle();
          updateMuteButton();
        });
      }
      if (difficultySelect) {
        difficultySelect.addEventListener('change', () => {
          setDifficulty(difficultySelect.value);
        });
      }
      if (canvas) {
        canvas.addEventListener('pointerdown', handlePointerDown);
      }
      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerUp);
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      document.addEventListener('minigame:menu', () => deactivateShooter());
      const resizeObserver = new ResizeObserver(() => resize());
      if (shell) resizeObserver.observe(shell);
    }

    function handlePointerDown(event) {
      if (!state.active) return;
      if (canvas) {
        try { canvas.setPointerCapture(event.pointerId); } catch (err) {}
      }
      activePointerId = event.pointerId;
      const pos = pointerToCanvas(event);
      player.pointerActive = true;
      player.targetX = pos.x;
      player.targetY = pos.y;
    }

    function handlePointerMove(event) {
      if (!state.active) return;
      if (activePointerId !== null && event.pointerId !== activePointerId) return;
      if (!player.pointerActive) return;
      const pos = pointerToCanvas(event);
      player.targetX = pos.x;
      player.targetY = pos.y;
    }

    function handlePointerUp(event) {
      if (activePointerId !== null && event.pointerId !== activePointerId) return;
      activePointerId = null;
      player.pointerActive = false;
    }

    function handleKeyDown(event) {
      if (!state.active) return;
      const moveKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyA', 'KeyD', 'KeyW', 'KeyS'];
      if (moveKeys.includes(event.code)) {
        keyState[event.code] = true;
        event.preventDefault();
      } else if (event.code === 'Space') {
        useBomb();
        event.preventDefault();
      } else if (event.code === 'Escape') {
        if (state.running) {
          showModeSelect();
        } else {
          goToMenu();
        }
        event.preventDefault();
      }
    }

    function handleKeyUp(event) {
      const moveKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyA', 'KeyD', 'KeyW', 'KeyS'];
      if (moveKeys.includes(event.code)) {
        keyState[event.code] = false;
        event.preventDefault();
      }
    }
    function setMode(mode) {
      if (mode !== 'score' && mode !== 'survival') mode = 'score';
      state.mode = mode;
      root.dataset.mode = mode;
      modeButtons.forEach((btn) => {
        const active = btn.getAttribute('data-mode-select') === mode;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-selected', active ? 'true' : 'false');
      });
      updateBestLabel();
      updateHUD();
    }

    function setDifficulty(diff) {
      if (!difficultySettings[diff]) diff = 'normal';
      state.difficulty = diff;
      state.config = difficultySettings[diff];
      if (difficultySelect && difficultySelect.value !== diff) {
        difficultySelect.value = diff;
      }
      updateBestLabel();
      updateHUD();
    }

    function bestKey(mode, difficulty) {
      return `danmaku_surfer_best_${mode}_${difficulty}`;
    }

    function updateBestLabel() {
      const key = bestKey(state.mode, state.difficulty);
      const stored = parseInt(localStorage.getItem(key), 10);
      state.bestScore = Number.isFinite(stored) ? stored : 0;
      if (bestLabel) bestLabel.textContent = state.bestScore.toLocaleString();
    }

    function saveBestScore() {
      const key = bestKey(state.mode, state.difficulty);
      if (state.score > state.bestScore) {
        state.bestScore = state.score;
        localStorage.setItem(key, String(state.score));
        if (bestLabel) bestLabel.textContent = state.bestScore.toLocaleString();
        return true;
      }
      return false;
    }

    function updateMuteButton() {
      if (!muteBtn) return;
      muteBtn.textContent = audio.muted ? '🔇' : '🔊';
      muteBtn.setAttribute('aria-pressed', audio.muted ? 'true' : 'false');
    }

    function updateHUD() {
      if (scoreLabel) scoreLabel.textContent = Math.round(state.score).toLocaleString();
      if (timerLabel) {
        timerLabel.textContent = state.mode === 'score'
          ? `${Math.max(0, state.timer).toFixed(1)}s`
          : `${Math.floor(state.elapsed).toString()}s`;
      }
      if (hpLabel) hpLabel.textContent = Math.max(0, state.hp).toString();
      if (bombLabel) bombLabel.textContent = state.bombs.toString();
      if (shieldLabel) shieldLabel.textContent = state.shield > 0 ? 'ON' : 'OFF';
      if (chainLabel) chainLabel.textContent = `x${state.chainMultiplier.toFixed(2)}`;
      updateMuteButton();
      if (bombBtn) bombBtn.disabled = !state.running || state.bombs <= 0;
    }

    function showToastMessage(text, duration = 1600) {
      if (!toast) return;
      toast.textContent = text;
      toast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = window.setTimeout(() => {
        toast.classList.remove('show');
        toastTimer = 0;
      }, duration);
    }

    function hideToast() {
      if (!toast) return;
      toast.classList.remove('show');
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = 0;
      }
    }
    function openShooter(mode = state.mode) {
      setMode(mode);
      if (difficultySelect) {
        setDifficulty(difficultySelect.value);
      } else {
        setDifficulty(state.difficulty);
      }
      clearStage();
      state.active = true;
      state.running = false;
      document.body.classList.remove('menu-active');
      document.body.classList.remove('maze-active');
      document.body.classList.add('shooter-active');
      root.setAttribute('aria-hidden', 'false');
      startOverlay.classList.remove('hidden');
      gameOverOverlay.classList.add('hidden');
      const menuScreen = document.getElementById('menuScreen');
      if (menuScreen) menuScreen.setAttribute('aria-hidden', 'true');
      lastFrame = performance.now();
      updateBestLabel();
      updateHUD();
    }

    function startGame(mode = state.mode) {
      openShooter(mode);
      if (width <= 0 || height <= 0) resize();
      state.running = true;
      state.elapsed = 0;
      state.realTime = 0;
      state.score = 0;
      state.chainCount = 0;
      state.chainTimer = 0;
      state.chainMultiplier = 1;
      state.slowMoTimer = 0;
      state.timeScale = 1;
      state.bombCooldown = 0;
      state.config = difficultySettings[state.difficulty] || difficultySettings.normal;
      state.bombs = state.config.bombs;
      state.shield = 0;
      state.hp = state.config.hp;
      state.spawnTimer = 0.4;
      state.timer = 60;
      player.x = width * 0.5;
      player.y = height - 80;
      player.fireCooldown = 0;
      player.pointerActive = false;
      player.invincible = 1.0;
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      clearStage();
      updateBestLabel();
      updateHUD();
      hideToast();
      showToastMessage(state.mode === 'score' ? '60秒で限界突破！' : '生き残り続けよう！', 1500);
    }

    function showModeSelect() {
      state.running = false;
      startOverlay.classList.remove('hidden');
      gameOverOverlay.classList.add('hidden');
      updateHUD();
    }

    function goToMenu() {
      deactivateShooter();
      if (window.miniGameMenu && typeof window.miniGameMenu.showMenu === 'function') {
        window.miniGameMenu.showMenu();
      } else {
        document.body.classList.add('menu-active');
        document.body.classList.remove('shooter-active');
      }
    }

    function deactivateShooter() {
      hideToast();
      state.active = false;
      state.running = false;
      document.body.classList.remove('shooter-active');
      root.setAttribute('aria-hidden', 'true');
      startOverlay.classList.remove('hidden');
      gameOverOverlay.classList.add('hidden');
      player.pointerActive = false;
      activePointerId = null;
      clearStage();
      updateHUD();
    }

    function clearStage() {
      bullets.length = 0;
      enemies.length = 0;
      enemyBullets.length = 0;
      items.length = 0;
      particles.length = 0;
      floatingTexts.length = 0;
      formations.clear();
    }
    function loop(now) {
      const realDt = Math.min((now - lastFrame) / 1000, 0.1);
      lastFrame = now;
      if (!state.active) {
        updateStars(realDt * 0.5);
        draw();
        requestAnimationFrame(loop);
        return;
      }
      if (state.slowMoTimer > 0) {
        state.slowMoTimer = Math.max(0, state.slowMoTimer - realDt);
      }
      const slow = state.slowMoTimer > 0 ? 0.4 : 1;
      state.timeScale = slow;
      const dt = realDt * (state.running ? slow : 0.5);
      updateStars(realDt * (state.running ? slow : 0.5));
      if (state.running) {
        updateGame(realDt * slow, realDt);
      } else {
        if (state.chainTimer > 0) {
          state.chainTimer = Math.max(0, state.chainTimer - realDt);
          if (state.chainTimer === 0) {
            state.chainCount = 0;
            state.chainMultiplier = 1;
          }
        }
        updateParticles(dt);
        updateFloatingTexts(dt);
      }
      applyScreenShake(realDt);
      draw();
      requestAnimationFrame(loop);
    }

    function updateGame(dt, realDt) {
      state.elapsed += dt;
      state.realTime += realDt;
      if (state.mode === 'score') {
        state.timer = Math.max(0, 60 - state.elapsed);
      } else {
        state.timer = state.elapsed;
      }
      if (state.chainTimer > 0) {
        state.chainTimer = Math.max(0, state.chainTimer - realDt);
        if (state.chainTimer === 0) {
          state.chainCount = 0;
          state.chainMultiplier = 1;
        }
      }
      if (state.bombCooldown > 0) {
        state.bombCooldown = Math.max(0, state.bombCooldown - realDt);
      }
      updatePlayer(dt);
      updateBullets(dt);
      updateEnemies(dt, realDt);
      updateEnemyBullets(dt);
      updateItems(dt);
      updateParticles(dt);
      updateFloatingTexts(dt);
      updateHUD();
      if (state.mode === 'score' && state.timer <= 0) {
        finishGame('time');
      }
    }

    function updatePlayer(dt) {
      const config = state.config || difficultySettings.normal;
      const moveSpeed = player.speed * config.speed;
      let moveX = 0;
      let moveY = 0;
      if (keyState.ArrowLeft || keyState.KeyA) moveX -= 1;
      if (keyState.ArrowRight || keyState.KeyD) moveX += 1;
      if (keyState.ArrowUp || keyState.KeyW) moveY -= 1;
      if (keyState.ArrowDown || keyState.KeyS) moveY += 1;
      if (moveX !== 0 || moveY !== 0) {
        const len = Math.hypot(moveX, moveY) || 1;
        moveX /= len;
        moveY /= len;
        player.x += moveX * moveSpeed * dt;
        player.y += moveY * moveSpeed * dt;
      }
      if (player.pointerActive) {
        const dx = player.targetX - player.x;
        const dy = player.targetY - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 1) {
          const pointerSpeed = moveSpeed * 1.25;
          const step = Math.min(pointerSpeed * dt, dist);
          player.x += (dx / dist) * step;
          player.y += (dy / dist) * step;
        }
      }
      player.x = clamp(player.x, player.radius, width - player.radius);
      player.y = clamp(player.y, player.radius, height - player.radius);
      if (player.invincible > 0) {
        player.invincible = Math.max(0, player.invincible - dt);
      }
      player.fireCooldown -= dt;
      while (player.fireCooldown <= 0 && state.running) {
        firePlayerShot();
        player.fireCooldown += player.fireDelay;
      }
    }

    function firePlayerShot() {
      const speed = 560;
      bullets.push({ x: player.x - 6, y: player.y - player.radius - 2, vx: 0, vy: -speed, width: 4, height: 16, damage: 1 });
      bullets.push({ x: player.x + 6, y: player.y - player.radius - 2, vx: 0, vy: -speed, width: 4, height: 16, damage: 1 });
      audio.play('shot');
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (Math.abs(enemy.x - b.x) < (enemy.width * 0.5 + b.width * 0.5) &&
              Math.abs(enemy.y - b.y) < (enemy.height * 0.5 + b.height * 0.5)) {
            enemy.hp -= b.damage;
            enemy.hitFlash = 0.2;
            spawnSpark(b.x, b.y, enemy.color || 'rgba(255,255,255,0.9)');
            if (enemy.hp <= 0) {
              destroyEnemy(j, enemy, 'bullet');
            }
            hit = true;
            break;
          }
        }
        if (hit || b.y < -40) {
          bullets.splice(i, 1);
        }
      }
    }

    function spawnSpark(x, y, color) {
      particles.push({
        x,
        y,
        vx: (Math.random() * 2 - 1) * 80,
        vy: -120 - Math.random() * 60,
        life: 0.35,
        age: 0,
        size: 2.5,
        color
      });
    }

    function destroyEnemy(index, enemy, cause) {
      enemies.splice(index, 1);
      if (enemy.formationId && !enemies.some((e) => e.formationId === enemy.formationId)) {
        formations.delete(enemy.formationId);
      }
      const color = enemy.color || 'rgba(255,255,255,0.9)';
      spawnExplosion(enemy.x, enemy.y, color);
      const baseScore = Math.round(enemy.scoreValue * (state.config ? state.config.score : 1));
      registerKill(baseScore, enemy.x, enemy.y);
      dropItems(enemy);
      audio.play('explosion');
      addShake(cause === 'bomb' ? 16 : 9, cause === 'bomb' ? 0.45 : 0.25);
    }

    function registerKill(baseScore, x, y) {
      if (state.chainTimer > 0) {
        state.chainCount += 1;
      } else {
        state.chainCount = 1;
      }
      state.chainTimer = 0.8;
      state.chainMultiplier = Math.min(3, 1 + 0.15 * (state.chainCount - 1));
      const gained = Math.round(baseScore * state.chainMultiplier);
      state.score += gained;
      floatingTexts.push({ x, y, text: `+${gained.toLocaleString()}`, age: 0, life: 0.8, color: '#fefefe' });
      if (state.chainCount >= 2) {
        triggerSlowMo();
      }
      updateHUD();
    }

    function triggerSlowMo() {
      state.slowMoTimer = Math.min(0.6, state.slowMoTimer + 0.3);
    }

    function dropItems(enemy) {
      const intensity = Math.min(1, state.elapsed / (state.mode === 'score' ? 60 : 90));
      const config = state.config || difficultySettings.normal;
      const chipChance = enemy.type === 'medium' ? 0.9 : 0.65;
      if (Math.random() < chipChance) {
        const value = Math.round(config.chipValue * (0.8 + Math.random() * 0.4 + intensity * 0.4));
        items.push({ type: 'chip', x: enemy.x, y: enemy.y, vx: (Math.random() * 2 - 1) * 30, vy: 60 + Math.random() * 40, value, radius: 14, age: 0 });
      }
      const shieldChance = 0.08 + intensity * 0.05 + (enemy.type === 'medium' ? 0.05 : 0);
      if (state.shield === 0 && Math.random() < shieldChance) {
        items.push({ type: 'shield', x: enemy.x, y: enemy.y, vx: (Math.random() * 2 - 1) * 25, vy: 55, value: 0, radius: 16, age: 0 });
      }
      const bombChance = 0.05 + intensity * 0.04 + (enemy.type === 'medium' ? 0.04 : 0);
      if (Math.random() < bombChance) {
        items.push({ type: 'bomb', x: enemy.x, y: enemy.y, vx: (Math.random() * 2 - 1) * 20, vy: 65, value: 0, radius: 16, age: 0 });
      }
    }

    function spawnExplosion(x, y, color) {
      const count = 24;
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 80 + Math.random() * 140;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.6 + Math.random() * 0.3,
          age: 0,
          size: 3 + Math.random() * 3,
          color
        });
      }
    }

    function addShake(power, duration = 0.25) {
      screenShake.power = Math.max(screenShake.power, power);
      screenShake.duration = Math.max(screenShake.duration, duration);
      screenShake.time = 0;
    }

    function applyScreenShake(dt) {
      if (screenShake.duration > 0) {
        screenShake.time += dt;
        if (screenShake.time >= screenShake.duration) {
          screenShake.duration = 0;
          screenShake.power = 0;
          screenShake.time = 0;
        }
      }
    }

    function getShakeOffset() {
      if (screenShake.duration <= 0) return [0, 0];
      const progress = screenShake.time / screenShake.duration;
      const power = screenShake.power * (1 - progress);
      return [(Math.random() * 2 - 1) * power, (Math.random() * 2 - 1) * power];
    }
    function updateEnemies(dt, realDt) {
      const config = state.config || difficultySettings.normal;
      const intensity = Math.min(1, state.elapsed / (state.mode === 'score' ? 60 : 90));
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0) {
        spawnWave(intensity);
        const base = config.spawnInterval;
        const interval = Math.max(0.35, (base - intensity * 0.35) * (0.65 + Math.random() * 0.8));
        state.spawnTimer = interval;
      }
      formations.forEach((info) => (info.active = 0));
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        enemy.y += enemy.vy * dt;
        enemy.x += enemy.vx * dt;
        enemy.phase += dt;
        if (enemy.type === 'small') {
          enemy.x += Math.sin(enemy.phase * 3.2) * 30 * dt;
        } else if (enemy.type === 'formation') {
          enemy.x += Math.sin(enemy.phase * 2.5 + enemy.offset) * 22 * dt;
          const info = formations.get(enemy.formationId);
          if (info) info.active += 1;
        } else if (enemy.type === 'medium') {
          enemy.vx += Math.sin(enemy.phase * 2.4) * 6 * dt;
          enemy.fireCooldown -= dt;
          if (enemy.fireCooldown <= 0) {
            fireMedium(enemy, intensity);
            enemy.fireCooldown = enemy.fireRate;
          }
        }
        if (enemy.hitFlash > 0) {
          enemy.hitFlash = Math.max(0, enemy.hitFlash - dt);
        }
        if (enemy.y > height + 120 || enemy.x < -160 || enemy.x > width + 160) {
          enemies.splice(i, 1);
          continue;
        }
        if (state.running && checkCircleCollision(player.x, player.y, player.radius * 0.8, enemy.x, enemy.y, enemy.collisionRadius)) {
          destroyEnemy(i, enemy, 'ram');
          onPlayerHit();
        }
      }
      formations.forEach((info, id) => {
        if (!info.active) {
          formations.delete(id);
          return;
        }
        info.timer -= dt;
        if (!info.triggered && info.timer <= 0) {
          info.triggered = true;
          fireFormationBurst(id, intensity);
        }
      });
    }

    function spawnWave(intensity) {
      const config = state.config || difficultySettings.normal;
      const weightSmall = 0.55 - intensity * 0.15;
      const weightMedium = 0.3 + intensity * 0.25;
      const weightFormation = 0.15 + intensity * 0.25;
      const total = weightSmall + weightMedium + weightFormation;
      const r = Math.random() * total;
      if (r < weightSmall) {
        spawnSmallGroup(intensity);
      } else if (r < weightSmall + weightMedium) {
        spawnMediumEnemy(intensity);
      } else {
        spawnFormation(intensity);
      }
    }

    function spawnSmallGroup(intensity) {
      const count = 1 + Math.floor(Math.random() * 2 + intensity * 2);
      const config = state.config || difficultySettings.normal;
      for (let i = 0; i < count; i++) {
        const x = clamp(Math.random() * width, 40, width - 40);
        enemies.push({
          type: 'small',
          x,
          y: -30 - Math.random() * 80,
          vx: (Math.random() * 2 - 1) * 30,
          vy: (120 + Math.random() * 40) * config.speed * (1 + intensity * 0.5),
          width: 26,
          height: 26,
          hp: 1,
          scoreValue: 100,
          collisionRadius: 16,
          phase: Math.random() * Math.PI * 2,
          hitFlash: 0,
          color: 'hsl(190, 80%, 65%)'
        });
      }
    }

    function spawnMediumEnemy(intensity) {
      const config = state.config || difficultySettings.normal;
      const patternRoll = Math.random();
      enemies.push({
        type: 'medium',
        x: clamp(Math.random() * width, 60, width - 60),
        y: -60,
        vx: (Math.random() * 2 - 1) * 18,
        vy: (90 + Math.random() * 40) * config.speed * (1 + intensity * 0.4),
        width: 36,
        height: 36,
        hp: 3 + Math.floor(intensity * 2),
        scoreValue: 260,
        collisionRadius: 20,
        phase: Math.random() * Math.PI * 2,
        hitFlash: 0,
        fireCooldown: 0.4 + Math.random() * 0.6,
        fireRate: (1.1 + Math.random() * 0.6) / config.bulletDensity,
        pattern: patternRoll < 0.5 ? 'straight' : patternRoll < 0.8 ? 'fan' : 'snake',
        color: 'hsl(40, 85%, 58%)'
      });
    }

    function spawnFormation(intensity) {
      const config = state.config || difficultySettings.normal;
      const count = 5;
      const spacing = 38;
      const startX = clamp(Math.random() * width, 100, width - 100);
      const id = nextFormationId++;
      formations.set(id, { timer: Math.max(0.8, 1.4 - intensity * 0.5), triggered: false, active: 0 });
      for (let i = 0; i < count; i++) {
        const offsetIndex = i - (count - 1) / 2;
        enemies.push({
          type: 'formation',
          formationId: id,
          x: startX + offsetIndex * spacing,
          y: -50 - Math.random() * 40,
          vx: (Math.random() * 2 - 1) * 10,
          vy: (110 + Math.random() * 30) * config.speed * (1 + intensity * 0.4),
          width: 28,
          height: 28,
          hp: 1,
          scoreValue: 160,
          collisionRadius: 16,
          phase: Math.random() * Math.PI * 2,
          offset: offsetIndex,
          hitFlash: 0,
          color: 'hsl(280, 80%, 72%)'
        });
      }
    }

    function fireMedium(enemy, intensity) {
      const config = state.config || difficultySettings.normal;
      const speed = 220 * config.bulletSpeed * (1 + intensity * 0.4);
      if (enemy.pattern === 'fan') {
        for (let i = -1; i <= 1; i++) {
          spawnEnemyBullet(enemy.x, enemy.y + 10, Math.PI / 2 + i * 0.18, speed, 'fan');
        }
      } else if (enemy.pattern === 'snake') {
        spawnEnemyBullet(enemy.x, enemy.y + 10, Math.PI / 2, speed * 0.9, 'snake', { amplitude: 0.45, frequency: 5.5 });
      } else {
        spawnEnemyBullet(enemy.x, enemy.y + 10, Math.PI / 2, speed, 'straight');
      }
      audio.play('fan');
    }

    function fireFormationBurst(id, intensity) {
      const config = state.config || difficultySettings.normal;
      const members = enemies.filter((e) => e.formationId === id);
      if (!members.length) return;
      const speed = 200 * config.bulletSpeed * (1 + intensity * 0.6);
      members.forEach((enemy, index) => {
        const spread = 0.8 + intensity * 0.5;
        const count = 6;
        for (let i = 0; i < count; i++) {
          const angle = Math.PI / 2 - spread / 2 + (spread / (count - 1 || 1)) * i + (index - (members.length - 1) / 2) * 0.04;
          spawnEnemyBullet(enemy.x, enemy.y, angle, speed, 'fan');
        }
      });
      audio.play('fan');
    }

    function spawnEnemyBullet(x, y, angle, speed, type, extra = {}) {
      enemyBullets.push({
        x,
        y,
        baseAngle: angle,
        speed,
        radius: type === 'fan' ? 8 : 6,
        type,
        amplitude: extra.amplitude || 0,
        frequency: extra.frequency || 0,
        age: 0
      });
    }

    function updateEnemyBullets(dt) {
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.age += dt;
        let angle = b.baseAngle;
        if (b.type === 'snake') {
          angle = b.baseAngle + Math.sin(b.age * b.frequency) * b.amplitude;
        }
        const vx = Math.cos(angle) * b.speed;
        const vy = Math.sin(angle) * b.speed;
        b.x += vx * dt;
        b.y += vy * dt;
        if (b.x < -40 || b.x > width + 40 || b.y > height + 60) {
          enemyBullets.splice(i, 1);
          continue;
        }
        if (!state.running) continue;
        if (checkCircleCollision(player.x, player.y, player.radius * 0.85, b.x, b.y, b.radius)) {
          enemyBullets.splice(i, 1);
          onPlayerHit();
        }
      }
    }

    function updateItems(dt) {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.age += dt;
        item.y += item.vy * dt;
        item.x += (item.vx || 0) * dt;
        item.vy += 30 * dt;
        if (item.y > height + 60) {
          items.splice(i, 1);
          continue;
        }
        if (state.running && checkCircleCollision(player.x, player.y, player.radius + 6, item.x, item.y, item.radius)) {
          collectItem(i, item);
        }
      }
    }

    function collectItem(index, item) {
      items.splice(index, 1);
      if (item.type === 'chip') {
        state.score += item.value;
        floatingTexts.push({ x: player.x, y: player.y - 20, text: `+${item.value}`, age: 0, life: 0.6, color: '#ffd75e' });
        audio.play('item');
      } else if (item.type === 'shield') {
        state.shield = 1;
        floatingTexts.push({ x: player.x, y: player.y - 20, text: 'SHIELD', age: 0, life: 0.8, color: '#78f8ff' });
        audio.play('shield');
      } else if (item.type === 'bomb') {
        state.bombs += 1;
        floatingTexts.push({ x: player.x, y: player.y - 20, text: 'BOMB +1', age: 0, life: 0.8, color: '#ff9a9a' });
        audio.play('item');
      }
      updateHUD();
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.age += dt;
        p.x += (p.vx || 0) * dt;
        p.y += (p.vy || 0) * dt;
        if (p.age >= p.life) {
          particles.splice(i, 1);
        }
      }
    }

    function updateFloatingTexts(dt) {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.age += dt;
        t.y -= 40 * dt;
        if (t.age >= t.life) {
          floatingTexts.splice(i, 1);
        }
      }
    }
    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          speed: 40 + Math.random() * 80,
          size: Math.random() * 1.5 + 0.4
        });
      }
    }

    function updateStars(dt) {
      if (!width || !height) return;
      for (const star of stars) {
        star.y += (star.speed + state.elapsed * 5) * dt;
        if (star.y > height) {
          star.y -= height;
          star.x = Math.random() * width;
        }
      }
    }

    function resize() {
      if (!canvas || !shell) return;
      const rect = shell.getBoundingClientRect();
      pixelRatio = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.floor(rect.width * pixelRatio));
      canvas.height = Math.max(1, Math.floor(rect.height * pixelRatio));
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      width = rect.width;
      height = rect.height;
      backgroundGradient = ctx.createLinearGradient(0, 0, 0, height);
      backgroundGradient.addColorStop(0, '#050911');
      backgroundGradient.addColorStop(1, '#0d1724');
      initStars();
      player.x = width * 0.5;
      player.y = height - 80;
    }

    function draw() {
      if (!ctx) return;
      ctx.save();
      ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      ctx.fillStyle = backgroundGradient || '#050910';
      ctx.fillRect(0, 0, width, height);
      drawStars();
      const [sx, sy] = getShakeOffset();
      ctx.translate(sx, sy);
      drawItems();
      drawEnemyBullets();
      drawEnemies();
      drawPlayerBullets();
      drawPlayer();
      drawParticlesLayer();
      drawFloatingTextsLayer();
      ctx.restore();
      if (state.slowMoTimer > 0) {
        ctx.save();
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        const alpha = Math.min(0.25, 0.05 + state.slowMoTimer * 0.2);
        ctx.fillStyle = `rgba(120, 200, 255, ${alpha.toFixed(3)})`;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    }

    function drawStars() {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (const star of stars) {
        ctx.globalAlpha = 0.35 + star.size * 0.1;
        ctx.fillRect(star.x, star.y, star.size, star.size * 2);
      }
      ctx.restore();
    }

    function drawItems() {
      for (const item of items) {
        ctx.save();
        ctx.translate(item.x, item.y);
        if (item.type === 'chip') {
          ctx.rotate(Math.PI / 4);
          ctx.fillStyle = 'rgba(255, 208, 96, 0.9)';
          ctx.fillRect(-10, -10, 20, 20);
        } else if (item.type === 'shield') {
          ctx.fillStyle = 'rgba(120, 240, 255, 0.8)';
          ctx.beginPath();
          ctx.arc(0, 0, 14, 0, Math.PI * 2);
          ctx.fill();
        } else if (item.type === 'bomb') {
          ctx.fillStyle = 'rgba(255, 110, 110, 0.85)';
          ctx.beginPath();
          ctx.arc(0, 0, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('B', 0, 1);
        }
        ctx.restore();
      }
    }

    function drawEnemyBullets() {
      ctx.save();
      for (const b of enemyBullets) {
        ctx.fillStyle = b.type === 'snake' ? 'rgba(255,120,200,0.85)' : 'rgba(255,190,120,0.85)';
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawEnemies() {
      ctx.save();
      for (const enemy of enemies) {
        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        ctx.globalAlpha = enemy.hitFlash > 0 ? 1 : 0.85;
        ctx.fillStyle = enemy.color || '#ffffff';
        if (enemy.type === 'small' || enemy.type === 'formation') {
          ctx.beginPath();
          ctx.moveTo(0, -enemy.height / 2);
          ctx.lineTo(-enemy.width / 2, enemy.height / 2);
          ctx.lineTo(enemy.width / 2, enemy.height / 2);
          ctx.closePath();
          ctx.fill();
        } else if (enemy.type === 'medium') {
          ctx.beginPath();
          ctx.ellipse(0, 0, enemy.width / 2, enemy.height / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }
      ctx.restore();
    }

    function drawPlayerBullets() {
      ctx.save();
      ctx.fillStyle = 'rgba(140, 220, 255, 0.9)';
      for (const b of bullets) {
        ctx.fillRect(b.x - b.width / 2, b.y - b.height, b.width, b.height);
      }
      ctx.restore();
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.beginPath();
      ctx.moveTo(0, -18);
      ctx.lineTo(-12, 14);
      ctx.lineTo(12, 14);
      ctx.closePath();
      ctx.fillStyle = player.invincible > 0 ? 'rgba(180,240,255,0.95)' : 'rgba(120,200,255,0.95)';
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(-6, 10);
      ctx.lineTo(6, 10);
      ctx.closePath();
      ctx.fillStyle = 'rgba(40, 80, 160, 0.9)';
      ctx.fill();
      if (state.shield > 0) {
        ctx.strokeStyle = `rgba(140, 240, 255, ${0.6 + Math.sin(state.realTime * 6) * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius + 8, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawParticlesLayer() {
      ctx.save();
      for (const p of particles) {
        const alpha = Math.max(0, 1 - p.age / p.life);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color || 'rgba(255,255,255,1)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawFloatingTextsLayer() {
      ctx.save();
      ctx.font = 'bold 16px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const t of floatingTexts) {
        const alpha = Math.max(0, 1 - t.age / t.life);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = t.color || 'rgba(255,255,255,1)';
        ctx.fillText(t.text, t.x, t.y);
      }
      ctx.restore();
    }

    function onPlayerHit() {
      if (!state.running) return;
      if (player.invincible > 0) return;
      if (state.shield > 0) {
        state.shield = 0;
        player.invincible = 1.1;
        spawnExplosion(player.x, player.y, 'rgba(150, 240, 255, 0.9)');
        audio.play('shield');
        showToastMessage('シールドが自動防御！', 1400);
      } else {
        state.hp = Math.max(0, state.hp - 1);
        player.invincible = 1.3;
        spawnExplosion(player.x, player.y, 'rgba(255, 120, 120, 0.9)');
        audio.play('hit');
        showToastMessage(state.hp > 0 ? `被弾！ 残りHP ${state.hp}` : '被弾！', 1400);
        if (state.hp <= 0) {
          finishGame('dead');
        }
      }
      addShake(16, 0.45);
      updateHUD();
    }

    function finishGame(reason) {
      if (!state.running) return;
      state.running = false;
      const cleared = reason === 'time';
      state.resultMessage = cleared ? 'タイムアップ！' : '撃墜…';
      gameOverTitle.textContent = state.resultMessage;
      finalScoreLabel.textContent = state.score.toLocaleString();
      const newRecord = saveBestScore();
      bestScoreLabel.textContent = state.bestScore.toLocaleString();
      gameOverOverlay.classList.remove('hidden');
      if (newRecord) {
        showToastMessage('ベストスコア更新！', 2000);
      }
      updateHUD();
    }

    function useBomb() {
      if (!state.running) return;
      if (state.bombs <= 0) return;
      if (state.bombCooldown > 0) return;
      state.bombs -= 1;
      state.bombCooldown = 0.8;
      audio.play('bomb');
      enemyBullets.length = 0;
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.type === 'medium') {
          enemy.hp -= 3;
        } else {
          enemy.hp = 0;
        }
        enemy.hitFlash = 0.35;
        if (enemy.hp <= 0) {
          destroyEnemy(i, enemy, 'bomb');
        }
      }
      addShake(24, 0.5);
      spawnExplosion(player.x, player.y - 20, 'rgba(255, 200, 120, 0.9)');
      showToastMessage('ボム発動！', 1200);
      updateHUD();
    }

    function checkCircleCollision(x1, y1, r1, x2, y2, r2) {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return dx * dx + dy * dy <= (r1 + r2) * (r1 + r2);
    }

    function pointerToCanvas(event) {
      if (!canvas) return { x: 0, y: 0 };
      const rect = canvas.getBoundingClientRect();
      const x = rect.width ? ((event.clientX - rect.left) / rect.width) * width : 0;
      const y = rect.height ? ((event.clientY - rect.top) / rect.height) * height : 0;
      return {
        x: clamp(x, player.radius, width - player.radius),
        y: clamp(y, player.radius, height - player.radius)
      };
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function createShooterAudio() {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctxAudio = AudioContext ? new AudioContext() : null;
      let muted = localStorage.getItem('danmaku_muted') === '1';
      let unlocked = false;
      let lastShotTime = 0;
      if (ctxAudio) {
        const resume = () => {
          if (!unlocked) {
            ctxAudio.resume();
            unlocked = true;
          }
        };
        window.addEventListener('pointerdown', resume, { once: true });
        window.addEventListener('keydown', resume, { once: true });
      }

      function playOscillator(type, startFreq, endFreq, duration, volume = 0.2) {
        if (!ctxAudio || muted) return;
        const now = ctxAudio.currentTime;
        const osc = ctxAudio.createOscillator();
        const gain = ctxAudio.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, now);
        if (endFreq && endFreq !== startFreq) {
          osc.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
        }
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(volume, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.connect(gain).connect(ctxAudio.destination);
        osc.start(now);
        osc.stop(now + duration + 0.05);
      }

      function playNoise(duration, volume = 0.2) {
        if (!ctxAudio || muted) return;
        const now = ctxAudio.currentTime;
        const buffer = ctxAudio.createBuffer(1, ctxAudio.sampleRate * duration, ctxAudio.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const source = ctxAudio.createBufferSource();
        source.buffer = buffer;
        const gain = ctxAudio.createGain();
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        source.connect(gain).connect(ctxAudio.destination);
        source.start(now);
        source.stop(now + duration);
      }

      return {
        play(name) {
          if (!ctxAudio || muted) return;
          const now = ctxAudio.currentTime;
          switch (name) {
            case 'shot':
              if (now - lastShotTime < 0.05) return;
              lastShotTime = now;
              playOscillator('triangle', 660, 520, 0.12, 0.12);
              break;
            case 'explosion':
              playNoise(0.4, 0.3);
              playOscillator('sawtooth', 180, 60, 0.35, 0.25);
              break;
            case 'bomb':
              playNoise(0.6, 0.45);
              playOscillator('sine', 140, 45, 0.6, 0.35);
              break;
            case 'item':
              playOscillator('square', 880, 1320, 0.25, 0.12);
              break;
            case 'hit':
              playOscillator('sawtooth', 220, 110, 0.3, 0.25);
              break;
            case 'shield':
              playOscillator('triangle', 520, 780, 0.3, 0.2);
              break;
            case 'fan':
              playOscillator('triangle', 400, 360, 0.18, 0.12);
              break;
            default:
              break;
          }
        },
        toggle() {
          muted = !muted;
          localStorage.setItem('danmaku_muted', muted ? '1' : '0');
        },
        get muted() {
          return muted || !ctxAudio;
        }
      };
    }
  })();
  </script>
</body>
</html>
